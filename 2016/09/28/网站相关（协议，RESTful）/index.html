
 <!DOCTYPE HTML>
<html lang="default">
<head>
  <meta charset="UTF-8">
  
    <title>网站相关（协议，RESTful） | 曾先生&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="曾奇">
    

    
    <meta name="description" content="TCP/IP在 TCP/IP 内部在 TCP/IP 中包含一系列用于处理数据通信的协议：1.TCP (传输控制协议) - 应用程序之间通信2.UDP (用户数据包协议) - 应用程序之间的简单通信3.IP (网际协议) - 计算机之间的通信4.ICMP (因特网消息控制协议) - 针对错误和状态5.DHCP (动态主机配置协议) - 针对动态寻址TCP 使用固定的连接

TCP 用于应用程序之间的">
<meta property="og:type" content="article">
<meta property="og:title" content="网站相关（协议，RESTful）">
<meta property="og:url" content="http://yoursite.com/2016/09/28/网站相关（协议，RESTful）/index.html">
<meta property="og:site_name" content="曾先生's Blog">
<meta property="og:description" content="TCP/IP在 TCP/IP 内部在 TCP/IP 中包含一系列用于处理数据通信的协议：1.TCP (传输控制协议) - 应用程序之间通信2.UDP (用户数据包协议) - 应用程序之间的简单通信3.IP (网际协议) - 计算机之间的通信4.ICMP (因特网消息控制协议) - 针对错误和状态5.DHCP (动态主机配置协议) - 针对动态寻址TCP 使用固定的连接

TCP 用于应用程序之间的">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg">
<meta property="og:image" content="http://img.blog.csdn.net/20160928115405070">
<meta property="og:image" content="https://pic2.zhimg.com/06ee404783540f0af299042057738a99_b.jpg">
<meta property="og:updated_time" content="2016-10-04T16:21:04.341Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网站相关（协议，RESTful）">
<meta name="twitter:description" content="TCP/IP在 TCP/IP 内部在 TCP/IP 中包含一系列用于处理数据通信的协议：1.TCP (传输控制协议) - 应用程序之间通信2.UDP (用户数据包协议) - 应用程序之间的简单通信3.IP (网际协议) - 计算机之间的通信4.ICMP (因特网消息控制协议) - 针对错误和状态5.DHCP (动态主机配置协议) - 针对动态寻址TCP 使用固定的连接

TCP 用于应用程序之间的">
<meta name="twitter:image" content="http://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png">

    
    <link rel="alternative" href="/atom.xml" title="曾先生&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="曾先生&#39;s Blog" title="曾先生&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="曾先生&#39;s Blog">曾先生&#39;s Blog</a></h1>
				<h2 class="blog-motto">飞面神教四川担担面教区主教</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于我</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/28/网站相关（协议，RESTful）/" title="网站相关（协议，RESTful）" itemprop="url">网站相关（协议，RESTful）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="曾奇" target="_blank" itemprop="author">曾奇</a>
		
  <p class="article-time">
    <time datetime="2016-09-28T04:23:39.000Z" itemprop="datePublished"> Published 2016-09-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP"><span class="toc-number">1.</span> <span class="toc-text">TCP/IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.1.</span> <span class="toc-text">在 TCP/IP 内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.2.</span> <span class="toc-text">TCP 使用固定的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.3.</span> <span class="toc-text">IP 是无连接的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.</span> <span class="toc-text">TCP/IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.5.</span> <span class="toc-text">域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.6.</span> <span class="toc-text">TCP/IP 协议族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.7.</span> <span class="toc-text">关于TCP/IP,SOCKET,HTTP之间的关系等：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.1.</span> <span class="toc-text">HTTP 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.2.</span> <span class="toc-text">HTTP请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.3.</span> <span class="toc-text">HTTP 响应头信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.4.</span> <span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP content-type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.6.</span> <span class="toc-text">http 和 https 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.7.</span> <span class="toc-text">关于RESTful：</span></a></li></ol></li></ol>
		
		</div>
		
		<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3>在 TCP/IP 内部</h3><br>在 TCP/IP 中包含一系列用于处理数据通信的协议：<br><br>1.TCP (传输控制协议) - 应用程序之间通信<br>2.UDP (用户数据包协议) - 应用程序之间的简单通信<br>3.IP (网际协议) - 计算机之间的通信<br>4.ICMP (因特网消息控制协议) - 针对错误和状态<br>5.DHCP (动态主机配置协议) - 针对动态寻址<br><br><h3>TCP 使用固定的连接</h3>

<p>TCP 用于<strong>应用程序之间的通信</strong>。<br>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方<strong>“握手”之后</strong>，TCP 将在两个应用程序之间建立一个<strong>全双工 (full-duplex) 的通信</strong>。<br>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。<br>UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。</p>
<h3>IP 是无连接的</h3>

<p>IP 用于<strong>计算机之间的通信</strong>。<br>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。<br>通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。<br>IP 负责将每个包路由至它的目的地。</p>
<h3>TCP/IP</h3>

<p><strong>TCP/IP 意味着 TCP 和 IP 在一起协同工作</strong>。</p>
<p><strong>TCP</strong> 负责应用软件（比如您的浏览器）和网络软件之间的通信。</p>
<p><strong>IP</strong> 负责计算机之间的通信。</p>
<p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。<br>IP 负责将包发送至接受者。</p>
<h3>域名</h3>

<p>当你键入一个像<a href="http://www.zengqi.top这样的域名，域名会被一种" target="_blank" rel="external">http://www.zengqi.top这样的域名，域名会被一种</a> DNS 程序翻译为数字。<br>在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。</p>
<p><strong>当一个新的域名连同其 TCP/IP 地址一起注册后，全世界的 DNS 服务器都会对此信息进行更新。</strong></p>
<h3>TCP/IP 协议族</h3>

<p><strong>TCP:</strong><br>TCP 用于从应用程序到网络的数据传输控制。<br>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</p>
<p><strong>IP:</strong><br>IP 负责计算机之间的通信。<br>IP 负责在因特网上发送和接收数据包。</p>
<p><strong>HTTP:</strong><br>HTTP 负责 web 服务器与 web 浏览器之间的通信。<br>HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。</p>
<p><strong>HTTPS:</strong><br>HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。<br>作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。</p>
<p><strong>SSL:</strong><br>SSL 协议用于为安全数据传输加密数据。</p>
<p><strong>MIME:</strong><br>MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。</p>
<p><strong>FTP:</strong><br>FTP 负责计算机之间的文件传输。</p>
<p><strong>DHCP:</strong><br>DHCP 用于向网络中的计算机分配动态 IP 地址。</p>
<p><strong>ARP:</strong><br>ARP用于通过 IP 来查找基于 IP 地址的计算机网卡的<strong>硬件地址</strong>。</p>
<p><strong>RARP:</strong><br>RARP 用于通过 IP 查找<strong>基于硬件地址的计算机网卡的 IP 地址</strong>。</p>
<h3>关于TCP/IP,SOCKET,HTTP之间的关系等：</h3>

<p>网络由下往上分为<br>　　物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。<br>　　通过初步的了解，我知道<strong>IP协议对应于网络层</strong>，<strong>TCP协议对应于传输层</strong>，而<strong>HTTP协议对应于应用层</strong>，<br>　　三者从本质上来说没有可比性，<br>　　<strong>socket则是对TCP/IP协议的封装和应用(程序员层面上)</strong>。<br>　　也可以说，<strong>TPC/IP</strong>协议是传输层协议，主要解决数据<strong>如何在网络中传输</strong>，<br>　　而<strong>HTTP</strong>是应用层协议，主要解决<strong>如何包装数据</strong>。<br>　　关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：<br>　　“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。<br>　　如果想要使传输的数据有意义，则必须使用到应用层协议。<br>　　应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。<br>　　WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”<br>　　而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，<strong>Socket本身并不是协议，而是一个调用接口(API)</strong>。<br>　　通过Socket，我们才能使用TCP/IP协议。<br>　　实际上，<strong>Socket跟TCP/IP协议没有必然的联系</strong>。<br>　　<strong>Socket编程接口在设计的时候，就希望也能适应其他的网络协议</strong>。<br>　　所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。<br>　　网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：<br>　　“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”<br>　　关于TCP/IP协议的相关只是，用博大精深来讲我想也不为过，单单查一下网上关于此类只是的资料和书籍文献的数量就知道，这个我打算会买一些经典的书籍(比如《TCP/IP详解：卷一、卷二、卷三》)进行学习，今天就先总结一些基于基于TCP/IP协议的应用和编程接口的知识，也就是刚才说了很多的HTTP和Socket。<br>　　CSDN上有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。<br>　　实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。<br>　　下面是一些经常在笔试或者面试中碰到的重要的概念，特在此做摘抄和总结。<br>　　一、什么是TCP连接的<strong>三次握手</strong><br>　　第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;<br>　　第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;<br>　　第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>　　握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。<br>　　理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。<br>　　断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)<br>　　二、利用Socket建立网络连接的步骤<br>　　<strong>建立Socket连接至少需要一对套接字</strong>，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>　　套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。<br>　　1、<strong>服务器监听</strong>：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br>　　2、<strong>客户端请求</strong>：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。<br>　　为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>　　3、<strong>连接确认</strong>：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。<br>　　而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。<br>　　三、HTTP链接的特点<br>　　HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。<br>　　<strong>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接</strong>。从建立连接到关闭连接的过程称为“一次连接”。<br>　　四、TCP和UDP的区别<br>　　1、TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性;<br>　　而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。<br>　　2、也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。<br>　　知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，<br>　　因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，<br>　　即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。</p>
<p>搞清楚一个问题，<strong>TCP为什么需要三次握手</strong>：</p>
<p>传输控制协议（Transmission Control Protocol, TCP）是一种面向连接的、可靠的、基于字节流的运输层（Transport layer）通信协议。是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的。互联网络与单个网络不同，因为互联网络的不同部分可能有着截然不同的拓扑、带宽、延迟、分组大小和其他参数。<strong>TCP的设计目标是能够动态的适应互联网络的这些特性，而且当面对多种失败的时候仍然能够健壮</strong>。</p>
<p>每一次TCP连接都需要三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。<strong>“三次握手”就发生在连接建立阶段</strong>。“三次握手”的具体过程网上有很多详解。可自行Google之。这里探讨的是——为什么需要“三次握手”。<br>我Google该问题答案后发现，网络上对于“三次握手”的过程都有很详细的描述，但对于为什么需要“三次握手”来建立连接却没有很好的答案。只能求助于书本了。</p>
<p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“<strong>网络中存在延迟的重复分组</strong>”的问题。这两种不用的表述其实阐明的是同一个问题。</p>
<p>谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<p>这个例子很清晰的阐释了“三次握手”对于建立可靠连接的意义。</p>
<p>在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“<strong>这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致.</strong> 而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。</p>
<hr>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3>HTTP 工作原理</h3>

<p>HTTP协议工作于<strong>客户端-服务端架构</strong>为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>
<p><strong>HTTP三点注意事项：</strong></p>
<p>1.<strong>HTTP是无连接</strong>：无连接的含义是<strong>限制每次连接只处理一个请求</strong>。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以<strong>节省传输时间</strong>。</p>
<p>2.<strong>HTTP是媒体独立的</strong>：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
<p>3.<strong>HTTP是无状态</strong>：HTTP协议是无状态协议。无状态是指<strong>协议对于事务处理没有记忆能力</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p><strong>客户端请求消息：</strong><br>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<strong>请求行</strong>（request line）、<strong>请求头部</strong>（header）、<strong>空行</strong>和<strong>请求数据</strong>四个部分组成，下图给出了请求报文的一般格式。<br><img src="http://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png" alt=""></p>
<p><strong>服务器响应消息：</strong><br>HTTP响应也由四个部分组成，分别是：<strong>状态行</strong>、<strong>消息报头</strong>、<strong>空行</strong>和<strong>响应正文</strong>。<br><img src="http://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg" alt=""></p>
<p>下面实例是一点典型的使用GET来传递数据的实例：</p>
<p>客户端请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.txt HTTP/1.1</span><br><span class="line">User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3</span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept-Language: en, mi</span><br></pre></td></tr></table></figure>
<p>服务端响应:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line">ETag: &quot;34aa387-d-1568eb00&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 51</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World! My payload includes a trailing CRLF.</span><br></pre></td></tr></table></figure>
<h3>HTTP请求方法</h3><br><img src="http://img.blog.csdn.net/20160928115405070" alt=""><br><br><h3>HTTP 响应头信息</h3>

<p>下面为应答头与其对应的说明：</p>
<p>1.Allow：服务器支持哪些请求方法（如GET、POST等）。</p>
<p>2.Content-Encoding：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，<strong>Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面</strong>。</p>
<p>3.Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</p>
<p>4.Content-Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</p>
<p>5.Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</p>
<p>6.Expires：应该在什么时候认为文档已经过期，从而不再缓存它？</p>
<p>7.Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</p>
<p>8.Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</p>
<p>9.Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)让浏览器读取指定的页面。" target="_blank" rel="external">http://host/path&quot;)让浏览器读取指定的页面。</a><br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href="http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。" target="_blank" rel="external">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a> </p>
<p>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。 </p>
<p>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p>
<p>10.Server：服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</p>
<p>11.Set-Cookie：设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</p>
<p>12.WWW-Authenticate：客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</p>
<h3>HTTP状态码</h3>

<p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<p>1<strong>:信息，服务器收到请求，需要请求者继续执行操作<br>2</strong>:成功，操作被成功接收并处理<br>3<strong>:重定向，需要进一步的操作以完成请求<br>4</strong>:客户端错误，请求包含语法错误或无法完成请求<br>5**:服务器错误，服务器在处理请求的过程中发生了错误</p>
<h3>HTTP content-type</h3>

<p>Content-Type，内容类型，一般是指网页中存在的Content-Type，<strong>用于定义网络文件的类型和网页的编码</strong>，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。<br>参见：<a href="http://www.runoob.com/http/http-content-type.html" target="_blank" rel="external">http://www.runoob.com/http/http-content-type.html</a></p>
<h3>http 和 https 有何区别？</h3>

<p>http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>
<p>https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。</p>
<p>关于GET与POST的不同与使用场景：</p>
<p>因为它们表达的语义不一样，这决定了主干网络可以对其做不同的处理。</p>
<p>get表达的是一种幂等的，只读的，纯粹的操作，即它除了返回结果不应该会产生其它副作用（如写数据库），因此<strong>绝大部分get请求（通常超过90%）都直接被CDN缓存了，这能大大减少web服务器的负担</strong>。</p>
<p>而post所表达的语义是非幂等的，有副作用的操作，所以必须交由web服务器处理。</p>
<p>把所有get请求换成post，意味着主干网络上的所有CDN都废掉了，web服务器要处理的请求数量将成百上千倍地增加，显然这不是一个聪明的做法！</p>
<p>我觉得对于一个真诚地讨论问题的人来说，以上解释就足够了，然而有些人非要把圈子绕大，那我就陪你们把圈子绕完咯</p>
<p>“get和post就是那几个字母的区别”</p>
<p>开发过web服务器的同学都知道，只要请求打到了服务器上，那么要怎么解释这个请求的内容就完全是服务器自己的事情了，只是web服务器开发框架通常会自动帮你做一些解析http请求的事情而已。</p>
<p>所以如果说客户端和服务端都是自己写，那当然很随意，想怎么玩就怎么玩好了，事实上在没有<strong>RESTful</strong>建议的时候，大家也的确玩得很随意。</p>
<p>然而说出“就是几个字母的区别”这种话仅仅是表达了“我搞过服务端开发”这层意思而已。</p>
<p>实际上问题真正<strong>困难</strong>的地方在于，<strong>网络上每天产生的请求数目庞大，并且其中绝大部分请求均为只读请求，如果所有这些请求都要交由web服务器直接处理，这无疑是巨大的资源浪费</strong>。所以大家自然能想到，假如我们能在请求到达web服务器之前，就对请求作一个<strong>初步的解析</strong>，得知请求的大致意图，对于不同意图的请求以不同方式满足（比如请求经过<strong>nginx</strong>的时候nginx就会解析请求头信息，然后根据这些信息把请求分配给合适的角色去进一步处理），那么事情就合理多了。</p>
<p>于是RESTful的建议就在这个时候应运而生了，它的出现正是为了解决http基础设施未能得到充分合理利用的问题。</p>
<p>所以我们开发一个服务的时候，选择http协议（而不是直接用tcp），最根本的原因是，我们希望它可以直接和浏览器打交道，可以借用现有的http基础设施，它的行为能被除自己的客户端以外的，网络中的其它角色所理解。 （而不是仅仅靠http解决文本编码问题）</p>
<p>这才是我们之所以强调get和post区别，强调“语义”的真正原因。</p>
<p></p><h3>关于RESTful：</h3><br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">理解RESTful架构</a><p></p>
<p>一句话概括：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p>
<p><strong>简介版介绍：</strong></p>
<p>0.REST不是”rest”这个单词，而是几个单词缩写。但即使那几个单词说出来，也无法理解在说什么 -_-!! （不是要贬低人，是我自己也理解困难）；<br>1.REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）；<br>2.Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“<strong>资源</strong>”是REST架构或者说整个网络处理的核心。比如：<br><a href="http://api.qc.com/v1/newsfeed" target="_blank" rel="external">http://api.qc.com/v1/newsfeed</a>: 获取某人的新鲜;<br><a href="http://api.qc.com/v1/friends" target="_blank" rel="external">http://api.qc.com/v1/friends</a>: 获取某人的好友列表;<br><a href="http://api.qc.com/v1/profile" target="_blank" rel="external">http://api.qc.com/v1/profile</a>: 获取某人的详细信息;<br>3.用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：<br>GET 用来获取资源，<br>POST 用来新建资源（也可以用于更新资源），<br>PUT 用来更新资源，<br>DELETE 用来删除资源。比如：<br>DELETE <a href="http://api.qc.com/v1/friends" target="_blank" rel="external">http://api.qc.com/v1/friends</a>: 删除某人的好友 （在http parameter指定好友id）<br>POST <a href="http://api.qc.com/v1/friends" target="_blank" rel="external">http://api.qc.com/v1/friends</a>: 添加好友<br>UPDATE <a href="http://api.qc.com/v1/profile" target="_blank" rel="external">http://api.qc.com/v1/profile</a>: 更新个人资料</p>
<p>禁止使用： GET <a href="http://api.qc.com/v1/deleteFriend,不然爬虫分分钟叫你怎么做人！" target="_blank" rel="external">http://api.qc.com/v1/deleteFriend,不然爬虫分分钟叫你怎么做人！</a><br>4.Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。当然还可以压缩HTTP传输时的数据（on-wire data compression）。<br>5.用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。</p>
<p>主要信息就这么点。最后是要解放思想，Web端不再用之前典型的PHP或JSP架构，而是改为前段渲染和附带处理简单的商务逻辑（比如AngularJS或者BackBone的一些样例）。<strong>Web端和Server只使用上述定义的API来传递数据和改变数据状态。格式一般是JSON。</strong>iOS和Android同理可得。由此可见，Web，iOS，Android和第三方开发者变为平等的角色通过一套API来共同消费Server提供的服务。</p>
<p><strong>为什么要用RESTful结构呢？</strong></p>
<p>大家都知道”古代”网页是前端后端融在一起的，比如之前的PHP，JSP等。在之前的桌面时代问题不大，但是近年来移动互联网的发展，<strong>各种类型的Client层出不穷，RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务</strong>。另外对于广大平台来说，比如Facebook platform，微博开放平台，微信公共平台等，它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful更是它们最好的选择。在RESTful架构下：<br><img src="https://pic2.zhimg.com/06ee404783540f0af299042057738a99_b.jpg" alt=""></p>
<p><strong>各端的具体实现：</strong><br>如上面的图所示，Server统一提供一套RESTful API，web+ios+android作为同等公民调用API。各端发展到现在，都有一套比较成熟的框架来帮开发者事半功倍。</p>
<p>– Server –<br>推荐： Spring MVC 或者 Jersey 或者 Play Framework<br>教程：<br><a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="external">SPRING</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/后端开发/">后端开发</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/09/28/网站相关（协议，RESTful）/" data-title="网站相关（协议，RESTful） | 曾先生&#39;s Blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/09/28/Nginx学习笔记/" title="Nginx学习笔记">
  <strong>上一篇：</strong><br/>
  <span>
  Nginx学习笔记</span>
</a>
</div>


<div class="next">
<a href="/2016/09/26/mysql学习笔记/"  title="mysql学习笔记">
 <strong>下一篇：</strong><br/> 
 <span>mysql学习笔记
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/09/28/网站相关（协议，RESTful）/" data-title="网站相关（协议，RESTful）" data-url="http://yoursite.com/2016/09/28/网站相关（协议，RESTful）/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP"><span class="toc-number">1.</span> <span class="toc-text">TCP/IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.1.</span> <span class="toc-text">在 TCP/IP 内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.2.</span> <span class="toc-text">TCP 使用固定的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.3.</span> <span class="toc-text">IP 是无连接的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.</span> <span class="toc-text">TCP/IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.5.</span> <span class="toc-text">域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.6.</span> <span class="toc-text">TCP/IP 协议族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.7.</span> <span class="toc-text">关于TCP/IP,SOCKET,HTTP之间的关系等：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.1.</span> <span class="toc-text">HTTP 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.2.</span> <span class="toc-text">HTTP请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.3.</span> <span class="toc-text">HTTP 响应头信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.4.</span> <span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP content-type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.6.</span> <span class="toc-text">http 和 https 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.7.</span> <span class="toc-text">关于RESTful：</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java编程思想读书笔记/" style="font-size: 18.57px;">Java编程思想读书笔记</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/TECH/" style="font-size: 12.86px;">TECH</a> <a href="/tags/后端开发/" style="font-size: 17.14px;">后端开发</a> <a href="/tags/数据结构与算法分析/" style="font-size: 11.43px;">数据结构与算法分析</a> <a href="/tags/机器学习/" style="font-size: 14.29px;">机器学习</a> <a href="/tags/程序人生/" style="font-size: 10px;">程序人生</a> <a href="/tags/程序员修炼之道读书笔记/" style="font-size: 14.29px;">程序员修炼之道读书笔记</a> <a href="/tags/算法4读书笔记/" style="font-size: 15.71px;">算法4读书笔记</a>
    </div>
  </div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://lucida.me/" target="_blank" title="Lucida&#39;s Blog">Lucida&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://hukai.me/" target="_blank" title="Hukai&#39;s Blog">Hukai&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://gank.io/" target="_blank" title="GANK">GANK</a>
            
          </li>
        
          <li>
            
            	<a href="http://stormzhang.com/" target="_blank" title="StormZhang&#39;s Blog">StormZhang&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.trinea.cn/" target="_blank" title="Trinea&#39;s Blog">Trinea&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=2766fecb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello , I&#39;m Zeng Qi , a Android developer , love Java , ML and Big Data . <br/>
			This is my blog , hope you will enjoy it . Let&#39;s make this world a better place .</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/18600103348" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/zengqi-ustb" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/ceng-qi-29" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:zengqiustb@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		© 2016 
		
		<a href="/about" target="_blank" title="曾奇">曾奇</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"zengqi"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
