
 <!DOCTYPE HTML>
<html lang="default">
<head>
  <meta charset="UTF-8">
  
    <title>21.并发 | 曾先生&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="曾奇">
    

    
    <meta name="description" content="到目前为止，你学到的都是有关 顺序编程 的知识。即程序中的所有事物在任意时刻都只能执行一个步骤。 下面我们应该学一学并发编程吧。
并发“具有可论证的确定性，但是实际上具有不可确定性”。实际上，你可能无法编写出能够针对你的并发程序生成故障条件的测试代码。
Web系统是最常见的Java应用系统之一，而基本的Web库类，Servlet具有天生的多线程性–这很重要，因为Web服务器经常包含多个处理器，而并">
<meta property="og:type" content="article">
<meta property="og:title" content="21.并发">
<meta property="og:url" content="http://yoursite.com/2016/10/23/21-并发/index.html">
<meta property="og:site_name" content="曾先生's Blog">
<meta property="og:description" content="到目前为止，你学到的都是有关 顺序编程 的知识。即程序中的所有事物在任意时刻都只能执行一个步骤。 下面我们应该学一学并发编程吧。
并发“具有可论证的确定性，但是实际上具有不可确定性”。实际上，你可能无法编写出能够针对你的并发程序生成故障条件的测试代码。
Web系统是最常见的Java应用系统之一，而基本的Web库类，Servlet具有天生的多线程性–这很重要，因为Web服务器经常包含多个处理器，而并">
<meta property="og:updated_time" content="2017-03-18T14:42:09.171Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="21.并发">
<meta name="twitter:description" content="到目前为止，你学到的都是有关 顺序编程 的知识。即程序中的所有事物在任意时刻都只能执行一个步骤。 下面我们应该学一学并发编程吧。
并发“具有可论证的确定性，但是实际上具有不可确定性”。实际上，你可能无法编写出能够针对你的并发程序生成故障条件的测试代码。
Web系统是最常见的Java应用系统之一，而基本的Web库类，Servlet具有天生的多线程性–这很重要，因为Web服务器经常包含多个处理器，而并">

    
    <link rel="alternative" href="/atom.xml" title="曾先生&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="曾先生&#39;s Blog" title="曾先生&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="曾先生&#39;s Blog">曾先生&#39;s Blog</a></h1>
				<h2 class="blog-motto">飞面神教四川担担面教区主教</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于我</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/23/21-并发/" title="21.并发" itemprop="url">21.并发</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="曾奇" target="_blank" itemprop="author">曾奇</a>
		
  <p class="article-time">
    <time datetime="2016-10-23T04:17:37.000Z" itemprop="datePublished"> Published 2016-10-23</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-1并发的多面性"><span class="toc-number">1.</span> <span class="toc-text">21.1并发的多面性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.1.</span> <span class="toc-text">21.1.1更快的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.2.</span> <span class="toc-text">21.1.2改进代码设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-2基本的线程机制"><span class="toc-number">2.</span> <span class="toc-text">21.2基本的线程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.1.</span> <span class="toc-text">21.2.1定义任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.2.</span> <span class="toc-text">21.2.2Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.3.</span> <span class="toc-text">21.2.3使用Executor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.4.</span> <span class="toc-text">21.2.4从任务中产生返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.5.</span> <span class="toc-text">21.2.5休眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.6.</span> <span class="toc-text">21.2.6优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.7.</span> <span class="toc-text">21.2.7让步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.8.</span> <span class="toc-text">21.2.8后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.9.</span> <span class="toc-text">21.2.9编码的变体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.10.</span> <span class="toc-text">21.2.10术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.11.</span> <span class="toc-text">21.1.11加入一个线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.12.</span> <span class="toc-text">21.2.12创建有响应的用户界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.13.</span> <span class="toc-text">21.2.13线程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.14.</span> <span class="toc-text">21.2.14捕获异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-3共享受限资源"><span class="toc-number">3.</span> <span class="toc-text">21.3共享受限资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.1.</span> <span class="toc-text">21.3.1不正确地访问资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.2.</span> <span class="toc-text">21.3.2解决共享资源竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.3.</span> <span class="toc-text">21.3.3原子性与易变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.4.</span> <span class="toc-text">21.3.4原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.5.</span> <span class="toc-text">21.3.5临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.6.</span> <span class="toc-text">21.3.6在其他对象上同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.7.</span> <span class="toc-text">21.3.7线程本地存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-4终结任务"><span class="toc-number">4.</span> <span class="toc-text">21.4终结任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.</span> <span class="toc-text">21.4.2在阻塞时终结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.</span> <span class="toc-text">21.4.3中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.3.</span> <span class="toc-text">21.4.4检查中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-5线程之间的协作"><span class="toc-number">5.</span> <span class="toc-text">21.5线程之间的协作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.1.</span> <span class="toc-text">21.5.1notify()与notifyAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.2.</span> <span class="toc-text">21.5.2notify()与notifyAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.3.</span> <span class="toc-text">21.5.3生产者与消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.4.</span> <span class="toc-text">21.5.4生产者-消费者与队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-6死锁"><span class="toc-number">6.</span> <span class="toc-text">21.6死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-7新类库中的构件"><span class="toc-number">7.</span> <span class="toc-text">21.7新类库中的构件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-8仿真"><span class="toc-number">8.</span> <span class="toc-text">21.8仿真</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-9性能调优"><span class="toc-number">9.</span> <span class="toc-text">21.9性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">9.1.</span> <span class="toc-text">21.9.1比较各类互斥技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">9.2.</span> <span class="toc-text">21.9.2免锁容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">9.3.</span> <span class="toc-text">21.9.3乐观加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">9.4.</span> <span class="toc-text">21.9.4ReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-10活动对象"><span class="toc-number">10.</span> <span class="toc-text">21.10活动对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-11总结"><span class="toc-number">11.</span> <span class="toc-text">21.11总结</span></a></li></ol>
		
		</div>
		
		<p><strong>到目前为止，你学到的都是有关 <em>顺序编程</em> 的知识。即程序中的所有事物在任意时刻都只能执行一个步骤。</strong> 下面我们应该学一学并发编程吧。</p>
<p>并发“具有可论证的确定性，但是实际上具有不可确定性”。实际上，你可能无法编写出能够针对你的并发程序生成故障条件的测试代码。</p>
<p>Web系统是最常见的Java应用系统之一，而基本的Web库类，Servlet具有天生的多线程性–这很重要，因为Web服务器经常包含多个处理器，而并发是充分利用这些处理器的理想方式。</p>
<h2 id="21-1并发的多面性"><a href="#21-1并发的多面性" class="headerlink" title="21.1并发的多面性"></a>21.1并发的多面性</h2><p>并发编程令人困惑的一个主要原因是：使用并发时需要解决的问题有多个，而实现并发的方式也有多种，而且在这两者之间没有明显的映射关系（而且通常只具有模糊的界限）。因此，必须理解所有这些问题和特例，以便有效地使用并发。</p>
<p>而并发解决的问题大体上可以分为两种：</p>
<p>1.速度<br>2.设计可管理性</p>
<h3>21.1.1更快的执行</h3>

<p>速度问题初听起来很简单：如果你想要一个程序运行得更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段。并发是用于多处理器编程的基本工具。</p>
<p>如果你有一台多处理器的机器，那么就可以在这些处理器之间分布多个任务，从而可以极大地提高吞吐量。这是使用强有力的多处理器web服务器的常见情况，在为每个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。</p>
<p>但是，并发通常是提高运行在<strong>单处理器</strong>上的程序的性能。听起来有些违背直觉。在单处理器上运行的并发程序开销确实应该比该程序的所有部分都顺序执行的开销大，因为其中增加了所谓<strong>上下文切换的代价</strong>（从一个任务切换到另一个任务）。</p>
<p>但是，有些情况下，情况就不同了，比如<strong>阻塞</strong>。如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续执行，因此这个程序可以保持继续向前执行。</p>
<p><strong>事实上，从性能的角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。</strong><br>这里需要注意这句话的前提哦，我想应该有这么几个：<br>1.从性能的角度看<br>2.在单处理器机器上</p>
<p>另一个例子是<strong>事件驱动的编程</strong>。考虑比如手机页面上的一个“退出”按钮。如果不使用并发，则产生可响应用户界面的唯一方式就是所有的任务都周期性地检查用户输入。通过创建单独的执行线程来响应用户的输入，即使这个线程在大多数时间里都是阻塞的，但是程序可以保证一定程度的可响应性。</p>
<p>实现并发最直接的方式是在操作系统级别使用<strong>进程</strong>。进程是运行在它自己的<strong>地址空间</strong>内的自包容的程序。</p>
<p>java采取了更加传统的方式，在顺序型语言的基础上提供了<strong>对线程的支持</strong>。与在多任务操作系统中分叉外部进程不同，线程机制是在由执行程序表示的单一进程中创建人物，<strong>这种方式产生的一个好处是操作系统的透明性</strong>。</p>
<h3>21.1.2改进代码设计</h3>


<h2 id="21-2基本的线程机制"><a href="#21-2基本的线程机制" class="headerlink" title="21.2基本的线程机制"></a>21.2基本的线程机制</h2><p>线程的一大好处是可以使你从处理器层次抽身出来，即代码不必知道它是运行在具有一个还是多个CPU的机器上。</p>
<h3>21.2.1定义任务</h3>

<p>线程可以驱动任务，因此你<strong>需要一种可以描述任务的方式</strong>。要想定义任务，只需实现Runnable接口并编写run()方法，使得该任务可以执行你的命令。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package test4.copy;</span><br><span class="line"></span><br><span class="line">class LiftOff implements Runnable&#123;</span><br><span class="line">L</span><br><span class="line">	protected int countDown = 10;</span><br><span class="line">	private static int taskCount = 0;</span><br><span class="line">	private final int id = taskCount++;</span><br><span class="line">	</span><br><span class="line">	public String status()&#123;</span><br><span class="line">		return &quot;#&quot;+id+&quot;(&quot;+(countDown&gt;0?countDown:&quot;liftoff&quot;)+&quot;),&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		while(countDown--&gt;0)&#123;</span><br><span class="line">			System.out.print(status());</span><br><span class="line">			Thread.yield();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标识符id可以用来区分任务的多个实例，它是final的，因为它一旦初始化就不希望被修改。</p>
<p>run()方法中通常总会有某种形式的循环。在run()中对静态方法Thread.yield()的调用时对<strong>线程调度器</strong>（java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种<strong>建议（注意，仅仅是建议，不能保证一定切换）</strong>，他在声明：我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机。</p>
<p>在下面的实例中，这个任务的run()不是由单独的线程驱动的，它是在main()中直接调用的（实际上，这里仍旧使用了线程，即总是分配给main()的那个线程）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThread&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		LiftOff lf = new LiftOff();</span><br><span class="line">		LiftOff lf1 = new LiftOff();</span><br><span class="line">		lf.run();</span><br><span class="line">		lf1.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(liftoff),#1(9),#1(8),#1(7),#1(6),#1(5),#1(4),#1(3),#1(2),#1(1),#1(liftoff),</span><br></pre></td></tr></table></figure>
<p>当从Runnable导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处–它不会产生任何内在的线程能力。要实现线程行为，你必须<strong>显式地将一个任务附着到线程上</strong>。</p>
<h3>21.2.2Thread类</h3>

<p>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThread&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Thread t = new Thread(new LiftOff());</span><br><span class="line">		t.start();</span><br><span class="line">		LiftOff lf = new LiftOff();</span><br><span class="line">		lf.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1(9),#1(8),#1(7),#1(6),#1(5),#1(4),#1(3),#0(9),#1(2),#1(1),#0(8),#1(liftoff),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(liftoff),</span><br></pre></td></tr></table></figure>
<p>因为main()所在的线程和t是两个不同的线程，都绑定了Runnable。Thread构造器只需要一个Runnable对象。调用Thread对象的start()方法为该线程执行必须的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务。输出说明不同任务的执行在线程被换进换出时混在了一起。</p>
<p>当main()创建Thread对象时，它并没有捕获任何对这些对象的引用。在使用普通对象时，这对于垃圾回收俩说是一场公平的游戏，但是在使用Thread对象时，情况就不同了。每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且在它的任务退出其run()并死亡之前，垃圾回收器无法清除它。你可以从输出中看到，这些任务确实运行到了结束，因此，<strong>一个线程会创建一个单独的执行线程，在对start()的调用完成之后，它仍旧会继续存在</strong>。</p>
<h3>21.2.3使用Executor</h3>

<p>Java SE5中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程。Executor在客户端和任务执行之间提供了一个间接层，与客户端直接执行任务不同，<strong>这个中介对象将执行任务</strong>。Executor允许你管理异步任务的执行，而无须显式地管理线程的生命周期。</p>
<p><strong>Executor在Java SE5/6中是启动任务的优选方法</strong>。</p>
<p><strong>我们可以使用Executor来代替显式地创建Thread对象</strong>。ExecutorService（具有服务生命周期的Executor，例如关闭）知道如何构建恰当的上下文来执行Runnable对象。在下面的例子中，CachedThreadPool将为每个任务都创建一个线程。注意，ExecutorService对象是使用静态的Executor方法创建的，这个方法可以确定其Executor类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CachedThreadPool&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">			exec.execute(new LiftOff());</span><br><span class="line">		&#125;</span><br><span class="line">		exec.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#0(9),#2(9),#1(9),#2(8),#0(8),#2(7),#2(6),#2(5),#1(8),#2(4),#0(7),#2(3),#2(2),#2(1),#1(7),#2(liftoff),#1(6),#0(6),#0(5),#0(4),#0(3),#0(2),#1(5),#0(1),#0(liftoff),#1(4),#1(3),#1(2),#1(1),#1(liftoff),</span><br></pre></td></tr></table></figure>
<p><strong>非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务</strong>。</p>
<p>shutdown()方法的调用可以防止新任务被提交给这个Executor，当前线程(在本例中，即驱动main()的线程)将继续运行在shutdown()被调用之前提交的所有任务。这个程序将在Executor中的所有任务完成之后尽快退出。</p>
<p>可以将CachedThreadPool替换成不同类型的Executor。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executor exec = Executors.newFixedThreadPool(Number)</span><br></pre></td></tr></table></figure>
<p>有了FixedThreadPool，你就可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数量。这可以节省时间，因为你不用为每个任务都固定地付出创建线程的开销。</p>
<p><strong>注意，在任务线程池中，现有线程在可能的情况下，都会被自动复用</strong>。</p>
<h3>21.2.4从任务中产生返回值</h3>

<p>Runnable是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()中返回的值的类型，并且必须使用ExecutorService.submit()方法调用它。下面是示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class TaskWithResult implements Callable&lt;String&gt;&#123;</span><br><span class="line">	private int id;</span><br><span class="line">	public TaskWithResult(int id)&#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String call()&#123;</span><br><span class="line">		return &quot;return of taskWithResult&quot;+id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CallableDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">		for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">			results.add(exec.submit(new TaskWithResult(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		for(Future&lt;String&gt; fs:results)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				//get()方法会阻塞直到完成</span><br><span class="line">				System.out.println(fs.get());</span><br><span class="line">			&#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;finally&#123;</span><br><span class="line">				exec.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return of taskWithResult0</span><br><span class="line">return of taskWithResult1</span><br><span class="line">return of taskWithResult2</span><br></pre></td></tr></table></figure>
<p>submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。你可以用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果。你也可以不用isDone()进行检查就直接调用get()，在这种情况下，get()将阻塞，直至结果准备就绪。</p>
<h3>21.2.5休眠</h3>

<p>影响任务行为的一种简单方法是调用sleep()，这将使任务中止执行给定的时间。</p>
<h3>21.2.6优先级</h3>

<p><strong>线程的优先级将该线程的重要性传递给了调度器</strong>。并不是优先权较低的线程将得不到执行（也就是说，优先权不会导致死锁）。<strong>优先级较低的线程仅仅是执行的频率较低</strong>。</p>
<p>在绝大多数时间内，所有线程都应该以默认的优先级运行。试图操作线程优先级通常是一种错误。优先级代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class SimplePriorities implements Runnable&#123;</span><br><span class="line">	private int countDown = 5;</span><br><span class="line">	private volatile double d;//no optimization</span><br><span class="line">	private int priority;</span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return Thread.currentThread()+&quot;:&quot;+countDown;</span><br><span class="line">	&#125;</span><br><span class="line">	public SimplePriorities(int priority) &#123;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">		this.priority = priority;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		Thread.currentThread().setPriority(priority);</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			//a expensive,interruptable operation</span><br><span class="line">			for(int i=0;i&lt;1000;i++)&#123;</span><br><span class="line">				d+=(Math.PI+Math.E)/(double)i;</span><br><span class="line">				if(i%1000==0)</span><br><span class="line">					Thread.yield();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(this);</span><br><span class="line">			if(--countDown==0) return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PriorityDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">			exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));</span><br><span class="line">		&#125;</span><br><span class="line">		exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));</span><br><span class="line">		exec.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-1-thread-3,1,main]:5</span><br><span class="line">Thread[pool-1-thread-6,10,main]:5</span><br><span class="line">Thread[pool-1-thread-5,1,main]:5</span><br><span class="line">Thread[pool-1-thread-6,10,main]:4</span><br><span class="line">Thread[pool-1-thread-4,1,main]:5</span><br><span class="line">Thread[pool-1-thread-6,10,main]:3</span><br><span class="line">Thread[pool-1-thread-2,1,main]:5</span><br><span class="line">Thread[pool-1-thread-6,10,main]:2</span><br><span class="line">Thread[pool-1-thread-2,1,main]:4</span><br><span class="line">Thread[pool-1-thread-1,1,main]:5</span><br><span class="line">Thread[pool-1-thread-2,1,main]:3</span><br><span class="line">Thread[pool-1-thread-6,10,main]:1</span><br><span class="line">Thread[pool-1-thread-5,1,main]:4</span><br><span class="line">Thread[pool-1-thread-5,1,main]:3</span><br><span class="line">Thread[pool-1-thread-3,1,main]:4</span><br><span class="line">Thread[pool-1-thread-5,1,main]:2</span><br><span class="line">Thread[pool-1-thread-3,1,main]:3</span><br><span class="line">Thread[pool-1-thread-2,1,main]:2</span><br><span class="line">Thread[pool-1-thread-3,1,main]:2</span><br><span class="line">Thread[pool-1-thread-1,1,main]:4</span><br><span class="line">Thread[pool-1-thread-4,1,main]:4</span><br><span class="line">Thread[pool-1-thread-5,1,main]:1</span><br><span class="line">Thread[pool-1-thread-3,1,main]:1</span><br><span class="line">Thread[pool-1-thread-1,1,main]:3</span><br><span class="line">Thread[pool-1-thread-2,1,main]:1</span><br><span class="line">Thread[pool-1-thread-4,1,main]:3</span><br><span class="line">Thread[pool-1-thread-1,1,main]:2</span><br><span class="line">Thread[pool-1-thread-4,1,main]:2</span><br><span class="line">Thread[pool-1-thread-1,1,main]:1</span><br><span class="line">Thread[pool-1-thread-4,1,main]:1</span><br></pre></td></tr></table></figure>
<p>如果将6的优先级也设为最低的话，结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-1-thread-1,1,main]:5</span><br><span class="line">Thread[pool-1-thread-2,1,main]:5</span><br><span class="line">Thread[pool-1-thread-1,1,main]:4</span><br><span class="line">Thread[pool-1-thread-2,1,main]:4</span><br><span class="line">Thread[pool-1-thread-3,1,main]:5</span><br><span class="line">Thread[pool-1-thread-2,1,main]:3</span><br><span class="line">Thread[pool-1-thread-2,1,main]:2</span><br><span class="line">Thread[pool-1-thread-1,1,main]:3</span><br><span class="line">Thread[pool-1-thread-3,1,main]:4</span><br><span class="line">Thread[pool-1-thread-4,1,main]:5</span><br><span class="line">Thread[pool-1-thread-2,1,main]:1</span><br><span class="line">Thread[pool-1-thread-1,1,main]:2</span><br><span class="line">Thread[pool-1-thread-1,1,main]:1</span><br><span class="line">Thread[pool-1-thread-5,1,main]:5</span><br><span class="line">Thread[pool-1-thread-3,1,main]:3</span><br><span class="line">Thread[pool-1-thread-6,1,main]:5</span><br><span class="line">Thread[pool-1-thread-4,1,main]:4</span><br><span class="line">Thread[pool-1-thread-5,1,main]:4</span><br><span class="line">Thread[pool-1-thread-6,1,main]:4</span><br><span class="line">Thread[pool-1-thread-4,1,main]:3</span><br><span class="line">Thread[pool-1-thread-5,1,main]:3</span><br><span class="line">Thread[pool-1-thread-3,1,main]:2</span><br><span class="line">Thread[pool-1-thread-6,1,main]:3</span><br><span class="line">Thread[pool-1-thread-5,1,main]:2</span><br><span class="line">Thread[pool-1-thread-4,1,main]:2</span><br><span class="line">Thread[pool-1-thread-5,1,main]:1</span><br><span class="line">Thread[pool-1-thread-3,1,main]:1</span><br><span class="line">Thread[pool-1-thread-6,1,main]:2</span><br><span class="line">Thread[pool-1-thread-4,1,main]:1</span><br><span class="line">Thread[pool-1-thread-6,1,main]:1</span><br></pre></td></tr></table></figure>
<p>可以看出，高的优先级并不是保证最先执行，而是一种频率问题。注意，<strong>优先级是在run()的开头部分设定的</strong>，在构造器中设置他们不会有任何好处，因为Executor在此刻还没有开始执行任务。</p>
<h3>21.2.7让步</h3>

<p>这个暗示将通过调用yield()方法来做出（不过这只是一个暗示，没有任何机制保证它将会被采纳）。</p>
<h3>21.2.8后台线程</h3>

<p>当所有非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。</p>
<p>必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemon = new Thread(new SimpleDaemons());</span><br><span class="line">daemon.setDaemon(true);//必须在start之前调用</span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure>
<p>可以通过调用isDaemon()方法来确定一个线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何线程都将被自动设置为后台线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class DaemonThreadFactory implements ThreadFactory&#123;</span><br><span class="line"></span><br><span class="line">	//重写newThread方法，使得每个创建的线程都为后台线程</span><br><span class="line">	@Override</span><br><span class="line">	public Thread newThread(Runnable r) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		Thread t = new Thread(r);</span><br><span class="line">		t.setDaemon(true);</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DaemonFromFactory implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		try&#123;</span><br><span class="line">			while(true)&#123;</span><br><span class="line">				TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">				System.out.println(Thread.currentThread()+&quot; &quot;+this);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;catch(InterruptedException e)&#123;</span><br><span class="line">			System.out.println(&quot;Interrupted&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		</span><br><span class="line">		//传入创建线程的工厂方法</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool(new DaemonThreadFactory());</span><br><span class="line">		for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">			exec.execute(new DaemonFromFactory());</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;all daemons started&quot;);</span><br><span class="line">		TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">all daemons started</span><br><span class="line">Thread[Thread-2,5,main] test4.copy.DaemonFromFactory@42d792c2</span><br><span class="line">Thread[Thread-4,5,main] test4.copy.DaemonFromFactory@189e7143</span><br><span class="line">Thread[Thread-6,5,main] test4.copy.DaemonFromFactory@4a710158</span><br><span class="line">Thread[Thread-3,5,main] test4.copy.DaemonFromFactory@c1e719b</span><br><span class="line">Thread[Thread-5,5,main] test4.copy.DaemonFromFactory@202ad687</span><br><span class="line">Thread[Thread-9,5,main] test4.copy.DaemonFromFactory@7b4ef7f0</span><br><span class="line">Thread[Thread-0,5,main] test4.copy.DaemonFromFactory@48df2951</span><br><span class="line">Thread[Thread-1,5,main] test4.copy.DaemonFromFactory@692e1ca8</span><br><span class="line">Thread[Thread-7,5,main] test4.copy.DaemonFromFactory@6cb478f5</span><br><span class="line">Thread[Thread-8,5,main] test4.copy.DaemonFromFactory@2fd38f41</span><br><span class="line">Thread[Thread-7,5,main] test4.copy.DaemonFromFactory@6cb478f5</span><br><span class="line">Thread[Thread-6,5,main] test4.copy.DaemonFromFactory@4a710158</span><br><span class="line">Thread[Thread-2,5,main] test4.copy.DaemonFromFactory@42d792c2</span><br><span class="line">Thread[Thread-5,5,main] test4.copy.DaemonFromFactory@202ad687</span><br><span class="line">Thread[Thread-0,5,main] test4.copy.DaemonFromFactory@48df2951</span><br><span class="line">Thread[Thread-4,5,main] test4.copy.DaemonFromFactory@189e7143</span><br><span class="line">Thread[Thread-8,5,main] test4.copy.DaemonFromFactory@2fd38f41</span><br><span class="line">Thread[Thread-9,5,main] test4.copy.DaemonFromFactory@7b4ef7f0</span><br><span class="line">Thread[Thread-1,5,main] test4.copy.DaemonFromFactory@692e1ca8</span><br><span class="line">Thread[Thread-3,5,main] test4.copy.DaemonFromFactory@c1e719b</span><br><span class="line">Thread[Thread-7,5,main] test4.copy.DaemonFromFactory@6cb478f5</span><br><span class="line">Thread[Thread-2,5,main] test4.copy.DaemonFromFactory@42d792c2</span><br><span class="line">Thread[Thread-3,5,main] test4.copy.DaemonFromFactory@c1e719b</span><br><span class="line">Thread[Thread-6,5,main] test4.copy.DaemonFromFactory@4a710158</span><br><span class="line">Thread[Thread-5,5,main] test4.copy.DaemonFromFactory@202ad687</span><br><span class="line">Thread[Thread-9,5,main] test4.copy.DaemonFromFactory@7b4ef7f0</span><br><span class="line">Thread[Thread-1,5,main] test4.copy.DaemonFromFactory@692e1ca8</span><br><span class="line">Thread[Thread-0,5,main] test4.copy.DaemonFromFactory@48df2951</span><br><span class="line">Thread[Thread-8,5,main] test4.copy.DaemonFromFactory@2fd38f41</span><br><span class="line">Thread[Thread-4,5,main] test4.copy.DaemonFromFactory@189e7143</span><br><span class="line">Thread[Thread-7,5,main] test4.copy.DaemonFromFactory@6cb478f5</span><br><span class="line">Thread[Thread-6,5,main] test4.copy.DaemonFromFactory@4a710158</span><br><span class="line">Thread[Thread-3,5,main] test4.copy.DaemonFromFactory@c1e719b</span><br><span class="line">Thread[Thread-4,5,main] test4.copy.DaemonFromFactory@189e7143</span><br><span class="line">Thread[Thread-0,5,main] test4.copy.DaemonFromFactory@48df2951</span><br><span class="line">Thread[Thread-2,5,main] test4.copy.DaemonFromFactory@42d792c2</span><br><span class="line">Thread[Thread-1,5,main] test4.copy.DaemonFromFactory@692e1ca8</span><br><span class="line">Thread[Thread-8,5,main] test4.copy.DaemonFromFactory@2fd38f41</span><br><span class="line">Thread[Thread-5,5,main] test4.copy.DaemonFromFactory@202ad687</span><br><span class="line">Thread[Thread-9,5,main] test4.copy.DaemonFromFactory@7b4ef7f0</span><br></pre></td></tr></table></figure>
<p>可以试试将<code>t.setDaemon(true)</code> 注释掉，那么程序将会一直执行死循环。</p>
<p>值得注意的是，后台线程在不执行finally子句的情况下就会终止其run()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ADaemon implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		try&#123;</span><br><span class="line">			System.out.println(&quot;starting a daemon&quot;);</span><br><span class="line">			TimeUnit.SECONDS.sleep(1);</span><br><span class="line">		&#125;catch(InterruptedException e)&#123;</span><br><span class="line">			System.out.println(&quot;catch exception&quot;);</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			System.out.println(&quot;finally&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DaemonDontRunFinally&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Thread thread = new Thread(new ADaemon());</span><br><span class="line">		thread.setDaemon(true);</span><br><span class="line">		thread.start();</span><br><span class="line">		System.out.println(&quot;start&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">starting a daemon</span><br></pre></td></tr></table></figure>
<p>如果注释掉<code>thread.setDaemon(true)</code>，就会执行finally语句。<br>当最后一个非后台线程终止时，<strong>后台线程会“突然”终止</strong>。如果你不想这样，可以使用非后台的Executor，因为<strong>Executor</strong>控制的所有任务可以同时被关闭。在这种情况下，关闭将以有序的方式执行。</p>
<h3>21.2.9编码的变体</h3>

<p><strong>到目前为止，所有的任务类都实现了Runnable</strong>。下面有两种简化的方式，分别是直接使用Thread和Runnable。<br>1.在非常简单的情况下，<strong>直接使用Thread</strong>继承这种方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleThread extends Thread&#123;</span><br><span class="line">	private int countDown = 5;</span><br><span class="line">	private static int threadCount=0;</span><br><span class="line">	public SimpleThread()&#123;</span><br><span class="line">		//store the thread name</span><br><span class="line">		super(Integer.toString(++threadCount));</span><br><span class="line">		start();</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return &quot;#&quot;+getName()+&quot;(&quot;+countDown+&quot;)&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			System.out.println(this);</span><br><span class="line">			if(--countDown==0)&#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">		new SimpleThread();</span><br><span class="line">	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1(5)</span><br><span class="line">#3(5)</span><br><span class="line">#3(4)</span><br><span class="line">#2(5)</span><br><span class="line">#2(4)</span><br><span class="line">#2(3)</span><br><span class="line">#2(2)</span><br><span class="line">#2(1)</span><br><span class="line">#3(3)</span><br><span class="line">#3(2)</span><br><span class="line">#3(1)</span><br><span class="line">#1(4)</span><br><span class="line">#1(3)</span><br><span class="line">#1(2)</span><br><span class="line">#1(1)</span><br></pre></td></tr></table></figure>
<p>2.直接使用Runnable，在Runnable内部维护一个Thread。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleRunnable implements Runnable&#123;</span><br><span class="line">	private int countDown = 5;</span><br><span class="line">	private Thread t = new Thread(this);</span><br><span class="line">	public SimpleRunnable() &#123;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return &quot;#&quot;+t.getName()+&quot;(&quot;+countDown+&quot;)&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			System.out.println(this);</span><br><span class="line">			try &#123;</span><br><span class="line">				TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			if(--countDown==0)&#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">		new SimpleRunnable();</span><br><span class="line">	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式，特殊点在于，<strong>实现接口使得你可以继承另一个不同的类，而从Thread继承将不行</strong>。</p>
<h3>21.2.10术语</h3>

<p>你应该注意到了，<strong>要执行的任务</strong>与<strong>驱动它的线程</strong>之间有一个差异。这个差异在java类库中尤为明显，因此你<strong>对Thread类实际没有任何控制权</strong>（并且这种隔离在使用执行器时更加明显，<strong>因为执行器将替你处理线程的创建和管理</strong>）。你创建任务，并通过某种方式将一个线程附着到任务上，以使得这个线程可以驱动任务。</p>
<p><strong>在java中，Thread类自身不执行任何操作，它只是驱动附着于它身上的任务</strong>。</p>
<h3>21.1.11加入一个线程</h3>

<p>一个线程可以在其他线程之上调用<strong>join()方法</strong>，其效果是<strong>等待一段时间直到第二个线程才继续执行</strong>。举例说明：</p>
<p>如果线程t1在另一个线程t2上调用t2.join()，那么该t1线程将被挂起，直到目标线程t2结束才恢复。（即t2.isAlive()返回为假）。</p>
<p><strong>对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法</strong>，这时需要用到try-catch子句。</p>
<h3>21.2.12创建有响应的用户界面</h3>

<p>如前所述，使用线程的动机之一就是创建有响应的用户界面。</p>
<h3>21.2.13线程组</h3>

<h3>21.2.14捕获异常</h3>

<p><strong>由于线程的本质属性，使得你不能捕获从线程中逃逸的异常</strong>。一旦异常逃出任务的run()方法，它就会向外传播到控制台。在java SE5以后，可以使用Executor来解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ExceptionThread implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		throw new RuntimeException();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		exec.execute(new ExceptionThread());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会产生异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;pool-1-thread-1&quot; java.lang.RuntimeException</span><br><span class="line">	at test4.copy.ExceptionThread.run(ExceptionThread.java:114)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Unknown Source)</span><br></pre></td></tr></table></figure>
<p>如果在main()方法中加入try-catch还是不能够捕捉它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		exec.execute(new ExceptionThread());</span><br><span class="line">		&#125;catch(Exception e)&#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>原因是，<strong>我们不能在一个线程中捕捉另一个线程的异常</strong>。</p>
<p>为了解决这个问题，可以用<strong>Executor</strong>。<strong>Thread.UncaughtExceptionHandler</strong>是java SE5中的新接口，它允许你在每个Thread对象上都附着一个异常处理器。其基本架构是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ExceptionThread2 implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">class HandlerThreadFactory implements ThreadFactory&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Thread newThread(Runnable r) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		Thread t = new Thread(r);</span><br><span class="line">		t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CaptureUncaughtException&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());</span><br><span class="line">		exec.execute(new ExceptionThread2());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方式是在Thread类中设置一个静态域，并将这个处理器设置为<strong>默认的未捕获异常处理器</strong>。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br></pre></td></tr></table></figure>
<h2 id="21-3共享受限资源"><a href="#21-3共享受限资源" class="headerlink" title="21.3共享受限资源"></a>21.3共享受限资源</h2><h3>21.3.1不正确地访问资源</h3>

<p>先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//IntGenerator.java</span><br><span class="line"></span><br><span class="line">public abstract class IntGenerator &#123;</span><br><span class="line">	private volatile boolean canceled =false;</span><br><span class="line">	public abstract int next();</span><br><span class="line">	public void cancel()&#123;</span><br><span class="line">		canceled = true;</span><br><span class="line">	&#125;</span><br><span class="line">	public boolean isCanceled()&#123;</span><br><span class="line">		return canceled;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//EvenChecker.java</span><br><span class="line"></span><br><span class="line">public class EvenChecker implements Runnable&#123;</span><br><span class="line">	private IntGenerator generator;</span><br><span class="line">	private final int id;</span><br><span class="line">	public EvenChecker(IntGenerator g,int ident)&#123;</span><br><span class="line">		generator = g;</span><br><span class="line">		id = ident;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		while (!generator.isCanceled())&#123;</span><br><span class="line">			int val = generator.next();</span><br><span class="line">			if(val%2!=0)&#123;</span><br><span class="line">				System.out.println(val+ &quot;not even&quot;);</span><br><span class="line">				generator.cancel();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void test(IntGenerator gp,int count) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		for(int i = 0;i&lt;count;i++)&#123;</span><br><span class="line">			exec.execute(new EvenChecker(gp,i));</span><br><span class="line">		&#125;</span><br><span class="line">		exec.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//EvenGenerator.java</span><br><span class="line"></span><br><span class="line">public class EvenGenerator extends IntGenerator&#123;</span><br><span class="line"></span><br><span class="line">	private int currentValue = 0;</span><br><span class="line">	public int next()&#123;</span><br><span class="line">		++currentValue;//这里很危险</span><br><span class="line">		Thread.yield();//增加切换线程的可能性</span><br><span class="line">		++currentValue;</span><br><span class="line">		return currentValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		System.out.println(&quot;start&quot;);</span><br><span class="line">		EvenChecker.test(new EvenGenerator(), 50);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个任务有可能在另一个任务执行第一个对currentValue的递增操作之后，但是没有执行第二个操作之前，调用next()方法（即，代码中被注释为“这里很危险”的地方）。事实上，上述代码将会很快出现错误。</p>
<p>有一点很重要，那就是要注意到递增程序自身也需要多个步骤，并且在递增过程中任务可能会被线程挂起–也就是说，<strong>在java中，递增不是原子性的操作</strong>。</p>
<h3>21.3.2解决共享资源竞争</h3>

<p>对于并发工作，你需要某种方式来防止两个任务访问<strong>相同的资源</strong>，至少在关键阶段不能出现这种情况。</p>
<p>共享资源一般是以对象形式存在的内存片段，但也可以是文件，输入/输出端口，或者是打印机。</p>
<p><strong>所有对象都自动含有单一的锁（也称为监视器）</strong>。当在对象上调用其任意synchronized方法的时候，此对象都被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。所以，对于某个特定对象来说，其所有synchronized方法共享同一个锁，这可以被用来防止多个任务同时访问该对象。</p>
<p>注意，<strong>在使用并发访问时，将域（field）设置为private是非常重要的</strong>，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会发生冲突。</p>
<p><strong>一个任务可以多次获得对象的锁</strong>。如果一个方法在同一个对象上调用了第二个方法，后者又调用了同一个对象的另一个方法，就会发生这种情况。JVM负责跟踪对象被加锁的次数。如果一个对象被解锁（即锁被完全释放），其计数变为0。在任务第一次给对象加锁的时候，计数变为1。</p>
<p><strong>针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问</strong>。</p>
<p>应该什么时候同步呢？可以运用<em>Brian的同步规则</em>：</p>
<p>如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。</p>
<p>要解决上面代码的错误只需要在next方法前加上synchronized关键字。</p>
<p><strong>使用显式的Lock对象</strong>：</p>
<p>上述代码可以改变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//MutexEvenGenerator.java</span><br><span class="line"></span><br><span class="line">public class MutexEvenGenerator extends IntGenerator&#123;</span><br><span class="line"></span><br><span class="line">    private int currentValue = 0;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    public int next()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            ++currentValue;//这里很危险</span><br><span class="line">            Thread.yield();</span><br><span class="line">            ++currentValue;</span><br><span class="line">            return currentValue;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        EvenChecker.test(new MutexEvenGenerator(), 50);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Lock对象必须被显式地创建，锁和释放</strong>。因此，它与内建的锁形式相比，代码缺乏优雅性。但是对于某些类型的问题来说，它更加灵活。</p>
<p>如果在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常。但是你没有任何机会去做清理工作，以维护系统使其处于良好状态。有了显式的Lock对象，你就可以使用finally将系统维护在正确的状态了。<strong>通常只有在解决特殊问题的时候，才使用显式地Lock对象</strong>。</p>
<h3>21.3.3原子性与易变性</h3>

<p>一个常常不正确的知识是“原子操作不需要进行同步控制”。原子操作是不能被线程调度机制中断的操作，一旦操作开始，那么它一定可以在可能发生的“上下文切换”之前执行完毕。</p>
<p><strong>原子性可以应用于除long和double之外的所有基本类型之上的“简单操作”</strong>。但是，当你定义long或double变量时，如果使用volatile关键字，就会获得（简单的赋值操作与返回操作的）原子性。</p>
<p><strong>不可过分依赖原子性而放弃同步</strong>！</p>
<p>在多处理器系统（现在以多核处理器的形式出现，即在单个芯片上有多个CPU）上，相对于单处理器系统而言，<strong>可视性问题远比原子性问题多得多</strong>。</p>
<p>一个任务做出的修改，即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的（例如，修改只是暂时地存储在本地处理器的缓存中），因此不同的任务对应用的状态有不同的视图。另一方面，同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的。</p>
<p><strong>如果没有同步机制。那么修改时可视将无法确定</strong>。</p>
<p><strong>volatile关键字还确保了应用中的可视性</strong>。如果你将一个域声明为volatile，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。<strong>即使使用了本地缓存，情况也是如此。volatile域会立即被写入到主存中，而读取操作就发生在主存中</strong>。</p>
<p>理解原子性和易变性不同的概念是很重要的。在非volatile域上的原子性不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值。<strong>如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问</strong>。<strong>同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或者语句块来防护，那就不必将其设置为是volatile的</strong>。</p>
<p>一个任务所做的任何写入操作对这个任务来说都是可视的，因此如果它只需要在这个任务内部可视，那么你就不需要将其设置为volatile。</p>
<p>什么才属于原子操作呢？对域中的值做赋值和返回操作通常都是原子性的。</p>
<p><strong>盲目地使用原子性概念</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//AtomicityTest.java</span><br><span class="line"></span><br><span class="line">public class AtomicityTest implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private int i = 0;</span><br><span class="line">    public int getValue()&#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">    private synchronized void evenIncrement()&#123;</span><br><span class="line">        i++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            evenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ExecutorService exexc = Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at = new AtomicityTest();</span><br><span class="line">        exexc.execute(at);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            int val = at.getValue();</span><br><span class="line">            if(val%2!=0)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码非常地迷惑了我一阵。发现它并发错误主要有：</p>
<p>1.尽管<code>return i</code>确实是原子性操作，但是缺少同步使得其数值可以在处于不稳定的中间状态时被读取。<br>2.由于i不是valatile的，因此还存在可视性问题。</p>
<p><strong>所以，getValue()和evenIncrement()必须是synchronized的</strong>。</p>
<p>如果你将一个域定义为volatile，那么它就会告诉编译器不要执行任何移除读取和写入操作的优化，<strong>这些操作的目的是用线程中的局部变量维护对这个域的精确同步</strong>。</p>
<h3>21.3.4原子类</h3>

<p>Java SE5引入了诸如AtomicInteger，AtomLong，AtomicReference等特殊的原子性变量类。举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerTest implements Runnable&#123;</span><br><span class="line">    private AtomicInteger i = new AtomicInteger(0);</span><br><span class="line">    public int getValue()&#123;</span><br><span class="line">        return i.get();</span><br><span class="line">    &#125;</span><br><span class="line">    private void evenIncrement()&#123;</span><br><span class="line">        i.addAndGet(2);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            evenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>21.3.5临界区</h3>

<p>有时希望多个线程同时访问方法中部分代码而不是整个方法，通过这种方式分离出来的代码段称为临界区（critical section），也使用关键字synchronized来建立。</p>
<p>synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(syncObject)&#123;</span><br><span class="line">//this code can be accessed by only one task at a time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在进入到这段代码前，必须得到syncObject对象的锁</strong>。</p>
<p><strong>演示如何把一个非线程安全的类，包装称应用于多线程环境下的类（很有意思）</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">//不是线程安全的类</span><br><span class="line">class Pair&#123;</span><br><span class="line">    private int x,y;</span><br><span class="line">    public Pair(int x,int y)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    public Pair()&#123;</span><br><span class="line">        this(0,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">    public void incrementX()&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    public void incrementY()&#123;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;x: &quot;+x+&quot; y: &quot;+y;</span><br><span class="line">    &#125;</span><br><span class="line">    public class PairValueNotEqual extends RuntimeException&#123;</span><br><span class="line">        public PairValueNotEqual()&#123;</span><br><span class="line">            super(&quot;value not equal: &quot;+Pair.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void checkState()&#123;</span><br><span class="line">        if(x!=y)&#123;</span><br><span class="line">            throw  new PairValueNotEqual();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程安全的manager，管理线程不安全的Pair类</span><br><span class="line">abstract class PairManager&#123;</span><br><span class="line">    AtomicInteger checkCounter = new AtomicInteger(0);</span><br><span class="line">    protected Pair p = new Pair();</span><br><span class="line">    public synchronized Pair getPair()&#123;</span><br><span class="line">        //make a copy to make the original safe</span><br><span class="line">        return new Pair(p.getX(),p.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //assume this a consuming operation</span><br><span class="line">    protected  void store()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void increment();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManager1 extends PairManager&#123;</span><br><span class="line"></span><br><span class="line">    //用同步方法</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void increment() &#123;</span><br><span class="line">        p.incrementX();</span><br><span class="line">        p.incrementY();</span><br><span class="line">        store();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManager2 extends PairManager&#123;</span><br><span class="line"></span><br><span class="line">    //用同步代码块</span><br><span class="line">    @Override</span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            p.incrementX();</span><br><span class="line">            p.incrementY();</span><br><span class="line">            store();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManipulator implements Runnable&#123;</span><br><span class="line">    private PairManager pm;</span><br><span class="line">    public PairManipulator(PairManager pm)&#123;</span><br><span class="line">        this.pm = pm;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            pm.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;pair: &quot;+pm.getPair()+&quot; checkCpunter= &quot;+pm.checkCounter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairChecker implements Runnable&#123;</span><br><span class="line">    private PairManager pm;</span><br><span class="line">    public PairChecker(PairManager pm)&#123;</span><br><span class="line">        this.pm = pm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            pm.checkCounter.incrementAndGet();</span><br><span class="line">            pm.getPair().checkState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CriticalSection&#123;</span><br><span class="line">    //测试两种实现方法</span><br><span class="line">    static void testApproaches(PairManager pman1,PairManager pman2)&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        PairManipulator pm1 = new PairManipulator(pman1);</span><br><span class="line">        PairManipulator pm2 = new PairManipulator(pman2);</span><br><span class="line">        PairChecker pcheck1 = new PairChecker(pman1);</span><br><span class="line">        PairChecker pcheck2 = new PairChecker(pman2);</span><br><span class="line">        exec.execute(pm1);</span><br><span class="line">        exec.execute(pm2);</span><br><span class="line">        exec.execute(pcheck1);</span><br><span class="line">        exec.execute(pcheck2);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;pm1: &quot;+pm1+&quot; pm2: &quot;+pm2);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        PairManager pman1 = new PairManager1();</span><br><span class="line">        PairManager pman2 = new PairManager2();</span><br><span class="line">        testApproaches(pman1,pman2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以想象一下这种情况：某人交给你一个非线程安全的Pair类，而你需要在一个线程环境下使用它。通过创建PairManager类就可以实现这一点，PairManager类持有一个Pair对象并控制它的一切访问。注意唯一的public方法是getPair()，它是synchronized的。对于抽象方法increment()，对increment()的同步控制将在实现的时候进行处理。</p>
<p><strong>注意</strong>：在PairManager1实现中，因为synchronized关键字不属于方法特征签名的组成部分，所以在覆盖方法的时候加上去。</p>
<h3>21.3.6在其他对象上同步</h3>

<p>有时需要在另一个对象上同步，但是如果你要这么做，就<strong>必须确保所有相关的任务都是在同一个对象上同步的</strong>。</p>
<p>下面演示了两个任务可以同时进入同一个对象，只要这个对象上的方法是在不同的锁上同步即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class DualSync &#123;</span><br><span class="line">    private Object syncObject = new Object();</span><br><span class="line">    public synchronized void f()&#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(&quot;f&quot;);</span><br><span class="line">            Thread.yield();</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void g()&#123;</span><br><span class="line">        synchronized (syncObject)&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(&quot;g&quot;);</span><br><span class="line">                Thread.yield();</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DualSync sync = new DualSync();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                sync.f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        sync.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>21.3.7线程本地存储</h3>

<p>防止任务在共享资源上产生冲突的<strong>第二种方式是根除对变量的共享</strong>。</p>
<p>创建和管理线程本地存储可以由ThreadLocal类来实现。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        private Random rand = new Random(47);</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            return rand.nextInt(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>ThreadLocal对象通常当做静态域存储</strong>。在创建ThreadLocal时，只能通过get()和set()方法来访问该对象的内容。</p>
<h2 id="21-4终结任务"><a href="#21-4终结任务" class="headerlink" title="21.4终结任务"></a>21.4终结任务</h2><p>在前面示例中，cancel()和isCanceled()（<strong>不突然终止</strong>）方法被放到一个所有任务都可以看到的类中。这些任务通过检查isCanceled()来确定何时终止他们自己，对于这个问题来说，这时一种合理的方式。但，在某些情况下，任务必须<strong>立刻终止</strong>。</p>
<h3>21.4.2在阻塞时终结</h3>

<p><strong>线程状态</strong>：（一个线程可以处于以下四种状态之一）</p>
<p><strong>1.新建（new）</strong>：</p>
<p>当线程被创建时，它只会短暂地处于这种状态。此时它已经分配了必需的系统资源，并执行了初始化。此刻线程已经有资格获得CPU时间了，之后调度器把这个线程转变为可运行状态或阻塞状态。</p>
<p><strong>2.就绪（runnable）</strong>：</p>
<p>在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，<strong>在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片非线程，它就可以运行</strong>。不同于阻塞和死亡状态。</p>
<p><strong>3.阻塞（blocked）</strong>：</p>
<p>线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配时间片给线程。直到线程重新进入了就绪状态，它才有可能执行操作。</p>
<p><strong>4.死亡（dead）</strong>：</p>
<p>处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已经结束，或不再是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断。</p>
<p><strong>进入阻塞状态</strong>：</p>
<p>一个任务进入阻塞状态，可能有如下原因：</p>
<p>1.<strong>通过调用sleep()使任务进入休眠状态</strong>，在这种情况下，任务在指定的时间内不会运行。<br>2.<strong>通过调用wait()使线程挂起</strong>。直到线程得到了notify()或者notifyAll()消息（或者在Java SE5中的concurrent类库中等价的signal()或者signalAll()消息），线程才会进入就绪状态。<br>3.任务在等待某个输入/输出完成。（<strong>I/O操作</strong>）<br>4.任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。（<strong>等待另一个任务释放锁</strong>）</p>
<p>有时，你希望能够终止处于阻塞状态的任务。你可能希望让它主动地终止，那么你就必须<strong>强制这个任务跳出阻塞状态</strong>。</p>
<h3>21.4.3中断</h3>

<p>Thread类包含interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态。<strong>如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptedException</strong>。当抛出该异常或者该任务调用Thread.interrupted()时，中断状态将被复位。<strong>Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方法</strong>。</p>
<p>为了调用interrupt()，你必须持有Thread对象。但是，新的类库concurrent似乎在避免对Thread对象的直接操作，转而尽量通过Executor来执行所有的操作。、</p>
<p><strong>如果你在Executor上调用shutdown()，那么它将发送一个interrupt()调用给它启动的所有线程</strong>。</p>
<p><strong>你能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用）。但是，你不能中断正在试图获取synchronized锁或者试图执行I/O操作的线程</strong>。</p>
<p>这优点令人烦恼，特别是在创建执行I/O任务时，因为这意味着I/O具有锁住你的多线程程序的潜在可能。特别是对于基于Web的程序，这更关乎利害。</p>
<p>对于这类I/O任务不能被有效中断的问题，有一个笨拙但是行之有效的方法，即<strong>关闭任务在其上发生阻塞的底层资源</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class CloseResource &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server = new ServerSocket(8080);</span><br><span class="line">        Socket socket = new Socket(&quot;localhost&quot;,8080);</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        exec.execute(new IOBlocked(is));</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(&quot;shuting down all the threads&quot;);</span><br><span class="line">        List&lt;Runnable&gt; a = exec.shutdownNow();</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(&quot;close end&quot;);</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IOBlocked implements Runnable&#123;</span><br><span class="line">    private InputStream in;</span><br><span class="line">    public IOBlocked(InputStream in)&#123;</span><br><span class="line">        this.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">            System.out.println(&quot;waiting for read&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                in.read();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                if(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(&quot;interrupted from blocked i/o&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(&quot; exiting run method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">waiting for read</span><br><span class="line">shuting down all the threads</span><br><span class="line">close end</span><br><span class="line">end</span><br><span class="line">interrupted from blocked i/o</span><br><span class="line"> exiting run method</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>幸运的是，在18章介绍的各种<strong>nio类</strong>提供了更加人性化的I/O中断。<strong>被阻塞的nio通道会自动地响应中断</strong>。<a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="external">更多关于NIO</a></p>
<p><strong>被互斥所阻塞</strong>：</p>
<p>下面演示同一个互斥量如何被同一个任务多次获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MultiLock &#123;</span><br><span class="line">    public synchronized void f1(int count)&#123;</span><br><span class="line">        if(count--&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;f1 calling f2 with count &quot;+count);</span><br><span class="line">            f2(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void f2(int count) &#123;</span><br><span class="line">        if(count--&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;f2 calling f1 with count &quot;+count);</span><br><span class="line">            f1(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        final MultiLock multiLock = new MultiLock();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                multiLock.f1(10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>21.4.4检查中断</h3>

<p>当你在线程上调用interrupt()方法时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时（如你所见，除了不可中断的I/O或被阻塞的synchronized方法之外，在其余的例外情况下，你无可事事）。</p>
<p>你可以通过<strong>调用interrupted()</strong>来检查中断状态，这不仅<strong>1.可以告诉你interrupt()是否被调用过</strong>，而且<strong>2.还可以清除中断状态</strong>。</p>
<h2 id="21-5线程之间的协作"><a href="#21-5线程之间的协作" class="headerlink" title="21.5线程之间的协作"></a>21.5线程之间的协作</h2><p>之前我们讨论的问题是线程彼此之间的干涉，现在我们将讨论彼此之间的协调。<strong>当任务协作时，关键问题是这些任务之间的握手</strong>。</p>
<h3>21.5.1notify()与notifyAll()</h3>

<p><strong>调用sleep()的时候锁并没有释放，调用yield()也属于这种情况</strong>，理解这一点很重要。另一方面，当一个任务在方法里遇到了对<strong>wait()</strong>的调用的时候，<strong>线程的执行将被挂起，对象上的锁被释放</strong>。</p>
<p>有<strong>两种形式的wait()</strong>。第一种版本<strong>1.接受毫秒数作为参数</strong>，含义与sleep()方法里参数的意思相同，<strong>都是指“在此期间暂停”</strong>。但是与sleep()不同的是，对于wait()而言：</p>
<p>1.在wait()期间对象锁是释放的<br>2.可以通过notify(),notifyAll()，或者令时间到期，从wait()中恢复执行</p>
<p>第二种，也是<strong>2.更常用形式的wait()不接受任何参数</strong>。这种wait()将无限等待下去，直到线程接收到notify()或者notifyAll()消息。</p>
<p><strong>注意</strong>：wait()，notify()以及notifyAll()有一个比较特殊的方面，那就是<strong>这些方法是基类Object的一部分，而不是属于Thread的一部分</strong>。</p>
<p><strong>只能在同步控制方法或者同步块里调用wait(),notify(),notifyAll()</strong>（因为他们都是要操作对象的锁啊！）。而sleep()方法因为不需要操作锁，所以sleep()方法可以在非同步控制方法里调用。</p>
<p>这里在补充一句：虽然在非同步方法或块中调用wait()等同类方法，能够通过编译。但运行的时候，会弹出<code>java.lang.IllegalMonitorStateException</code>异常。</p>
<p>WaxOMatic.java有两个过程：一个是将蜡涂到Car上，一个是抛光它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class WaxOMatic &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Car car = new Car();</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(new WaxOff(car));</span><br><span class="line">        exec.execute(new WaxOn(car));</span><br><span class="line">        TimeUnit.SECONDS.sleep(20);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car&#123;</span><br><span class="line">    private boolean waxOn = false;</span><br><span class="line">    public synchronized void waxed()&#123;</span><br><span class="line">        waxOn = true;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void buffed()&#123;</span><br><span class="line">        waxOn = false;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void waitForWaxing() throws InterruptedException &#123;</span><br><span class="line">        while(waxOn == false)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void waitForBuffing() throws InterruptedException &#123;</span><br><span class="line">        while(waxOn==true)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WaxOn implements Runnable&#123;</span><br><span class="line">    private Car car;</span><br><span class="line">    public WaxOn(Car car)&#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                System.out.println(&quot;wax on&quot;);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(200);</span><br><span class="line">                car.waxed();</span><br><span class="line">                car.waitForBuffing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(&quot;exiting via interrupt&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;ending wax on task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WaxOff implements Runnable&#123;</span><br><span class="line">    private Car car;</span><br><span class="line">    public WaxOff(Car car)&#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                car.waitForWaxing();</span><br><span class="line">                System.out.println(&quot;wax off&quot;);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(200);</span><br><span class="line">                car.buffed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(&quot;exiting via interrupt&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;ending wax off task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的过程还是比较简单的。</p>
<p>这里强调一点：<strong>必须用一个检查感兴趣的条件的while循环包围wait()</strong>。原因是：</p>
<p>1.可能有多个任务出于相同的原因在等待同一个锁，而第一个唤醒任务可能会改变这种状况。如果属于这种情况，那么这个任务应该被再次挂起，直至其感兴趣的条件发生变化。<br>2.在这个任务从其wait()中被唤醒的时刻，可能会有其他某个其他的任务已经做出了改变，从而使得这个任务在此时不能执行，或者执行其操作已显得无关紧要。此时，应该通过再次调用wait()来将其重新挂起。<br>3.也有可能某些任务处于不同的原因在等待你的对象上的说（在这种情况下必须使用notifyAll()）。在这种情况下，你需要检查是否已经由正确的原因唤醒，如果不是，就再次调用wait()。</p>
<p>因此，其本质就是要检查所感兴趣的特定条件，并在条件不满足的情况下返回到wait()中。<strong>惯用的方法就是使用while来编写这种代码</strong>。</p>
<p><strong>错失的信号</strong>：</p>
<p>如下编程方式可能会错失信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//T1：</span><br><span class="line">    synchronized (sharedMonitor)&#123;</span><br><span class="line">        //setup condition for T2</span><br><span class="line">        sharedMonitor.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //T2：</span><br><span class="line">    while(someCondition)&#123;</span><br><span class="line">        //point 1</span><br><span class="line">        synchronized (sharedMonitor)&#123;</span><br><span class="line">            sharedMonitor.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该问题的解决方案是防止在someCondition变量上产生竞争条件。下面是正确的编码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//T2：</span><br><span class="line">    synchronized (sharedMonitor)&#123;</span><br><span class="line">        while(someCondition)&#123;</span><br><span class="line">            sharedMonitor.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在T1首先执行，当控制返回T2时，它将发现条件发生了变化，从而不会进入wait()。反过来，如果T2首先执行，那么他将进入wait()，并且稍后会由T1唤醒。因此，信号不会错失。</p>
<p>其实上面的对比代码想表达的意思很简单，<strong>在synchronized块中运用while加wait()，</strong>正如前面在synchronized方法中运用while加wait()一样。</p>
<h3>21.5.2notify()与notifyAll()</h3>

<p>因为在技术上，可能会有多个任务在单个Car对象上处于wait()状态，因此调用notifyAll()比只调用notify()更安全。</p>
<p>使用notify()而不是notifyAll()是一种优化。<strong>使用notify()时，在众多等待同一个锁的任务中只有一个被唤醒</strong>。因此如果你希望使用notify()，就<strong>必须保证被唤醒的是恰当的任务</strong>。</p>
<p><strong>为了使用notify()，所有任务必须等待相同的条件</strong>，因为如果你有多个任务在等待不同的条件，那么你就不会直到是否唤醒了恰当的任务。如果使用notify()，当条件发生变化时，必须只有一个任务从中受益。</p>
<p>如果这些规则中有任何一条不满足，就必须使用notifyAll()而不是notify()。所以，<strong>总结一句话，使用notify()有很多限制</strong>。</p>
<p>一个令人困惑的描述：notifyAll()将唤醒“所有正在等待的任务”。这是否意味着，任何处于wait()状态的任务都将被任何对notifyAll()的调用而唤醒呢？不是的！<strong>事实上，当notifyAll()因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒</strong>。</p>
<h3>21.5.3生产者与消费者</h3>

<p>初级的生产者与消费者模型，一个饭店里有一个厨师和一个服务员，这个服务员必须等待厨师准备好膳食。当厨师准备好时，会通知服务员，之后服务员上菜，然后返回继续等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">class Meal&#123;</span><br><span class="line">    private final int orderNum;</span><br><span class="line">    public Meal(int orderNum)&#123;</span><br><span class="line">        this.orderNum = orderNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;meal : &quot;+orderNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WaitPerson implements Runnable&#123;</span><br><span class="line">    private Restaurant restaurant;</span><br><span class="line">    public WaitPerson(Restaurant restaurant)&#123;</span><br><span class="line">        this.restaurant = restaurant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                synchronized (this)&#123;//取得自身的锁</span><br><span class="line">                    while(restaurant.meal==null)&#123;//while将会保证在这里一直等待下去啊，直到条件变化</span><br><span class="line">                        wait();//等待厨师做饭</span><br><span class="line">                    &#125;</span><br><span class="line">                    Print.print(&quot;waitperson got &quot;+restaurant.meal);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (restaurant.chef)&#123;//之所以要取得chef的锁，是为了调用其notifyAll()</span><br><span class="line">                    restaurant.meal=null;</span><br><span class="line">                    restaurant.chef.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            Print.print(&quot;waitperson interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Chef implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private Restaurant restaurant;</span><br><span class="line">    private int count=0;</span><br><span class="line">    public Chef(Restaurant restaurant)&#123;</span><br><span class="line">        this.restaurant = restaurant;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                synchronized (this)&#123;//取得自身的锁</span><br><span class="line">                    while(restaurant.meal!=null)&#123;//while将会保证在这里一直等待下去啊，直到条件变化</span><br><span class="line">                        wait();//等待服务员拿走饭</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(++count==3)&#123;</span><br><span class="line">                        Print.print(&quot;out of food,closing&quot;);</span><br><span class="line">                        restaurant.exec.shutdownNow();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Print.print(&quot;order up&quot;);</span><br><span class="line">                synchronized (restaurant.waitPerson)&#123;//之所以要取得waitPerson的锁，是为了调用其notifyAll()</span><br><span class="line">                    restaurant.meal=new Meal(count);</span><br><span class="line">                    restaurant.waitPerson.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            Print.print(&quot;chef interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Restaurant &#123;</span><br><span class="line">    Meal meal;</span><br><span class="line">    Chef chef = new Chef(this);</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    WaitPerson waitPerson = new WaitPerson(this);</span><br><span class="line">    public Restaurant()&#123;</span><br><span class="line">        exec.execute(chef);</span><br><span class="line">        exec.execute(waitPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Restaurant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">order up</span><br><span class="line">waitperson got meal : 1</span><br><span class="line">order up</span><br><span class="line">waitperson got meal : 2</span><br><span class="line">out of food,closing</span><br><span class="line">order up</span><br><span class="line">chef interrupted</span><br><span class="line">waitperson got meal : 3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>注意，wait()被包装在一个while()语句中，这个语句在不断地测试正在等待的事物。在并发应用中，某个其他的任务可能会在WaitPerson被唤醒时，会突然插足并拿走订单，唯一安全的方式是使用下面这种wait()的惯用法（当然要在恰当的同步内部，并采用防止错失信号可能性的程序设计）。</p>
<p>对notifyAll()的调用必须首先捕获waitPerson上的锁，而在WaitPerson.run()中的对wait()的调用会自动地释放这个锁，因此这是有可能实现的。</p>
<p>在前面的示例中，对于一个任务而言，只有一个单一的地点用于存放对象，从而使得另一个任务稍后可以使用这个对象，<strong>也就是在WaitPerson和Chef中的Restaurant对象</strong>。但是，在<strong>典型</strong>的生产者和消费者实现中，应使用<strong>先进先出队列来存储被生产和消费的对象</strong>。</p>
<h3>21.5.4生产者-消费者与队列</h3>

<p><strong>wait()和notifyAll()方法以一种非常低级的方式解决了任务互操作的问题，即每次交互时都握手</strong>。</p>
<p>在很多情况下，你可以瞄向更高的抽象级别，使用<strong>同步队列</strong>来解决任务协作问题，<strong>同步队列在任何时候都只允许一个任务插入或移除元素</strong>。</p>
<p>在java.util.concurrent.BlockQueue接口中提供了这个队列，这个接口有大量的标准实现。你通常可以使用<strong>LinkedBlockingQueue</strong>，它是一个无界队列，还可以使用<strong>ArrayBlockingQueue</strong>，它具有固定的尺寸，因此你可以在它被阻塞之前，向其中放置有限数量的元素。</p>
<p>下面是一个例子：<br>吐司BlockingQueue，有一台机器有三个任务：一个制作吐司，一个给吐司抹黄油，另一个在抹过黄油的吐司上凃酱。我们可以通过各个处理过程之间的BlockingQueue来运行这个吐司制作程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">class Toast&#123;</span><br><span class="line">	//使用enum</span><br><span class="line">    public enum Status&#123;DRY,BUTTERED,JAMMED&#125;</span><br><span class="line">    private Status status = Status.DRY;</span><br><span class="line">    private final int id;</span><br><span class="line">    public Toast(int id)&#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void butter()&#123;</span><br><span class="line">        status = Status.BUTTERED;</span><br><span class="line">    &#125;</span><br><span class="line">    public void jam()&#123;</span><br><span class="line">        status = Status.JAMMED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Status getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;toast &quot;+id+&quot; : &quot;+status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自定义自己的Queue</span><br><span class="line">class ToastQueue extends LinkedBlockingQueue&lt;Toast&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line">//step1</span><br><span class="line">class Toaster implements Runnable&#123;</span><br><span class="line">    private ToastQueue toastQueue;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    private Random rand = new Random(47);</span><br><span class="line">    public Toaster(ToastQueue toastQueue)&#123;</span><br><span class="line">        this.toastQueue = toastQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(100+rand.nextInt(500));</span><br><span class="line">                //make toast</span><br><span class="line">                Toast t = new Toast(count++);</span><br><span class="line">                Print.print(t.toString());</span><br><span class="line">                //insert into queue</span><br><span class="line">                toastQueue.put(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            Print.print(&quot;toaster interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Print.print(&quot;toaster off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//step2:apply butter to toast</span><br><span class="line">class Butterer implements Runnable&#123;</span><br><span class="line">    private ToastQueue dryQueue,butteredQueue;</span><br><span class="line">    public Butterer(ToastQueue dryQueue,ToastQueue butteredQueue)&#123;</span><br><span class="line">        this.dryQueue = dryQueue;</span><br><span class="line">        this.butteredQueue = butteredQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                //block until next piece of toast if available</span><br><span class="line">                Toast t = dryQueue.take();</span><br><span class="line">                t.butter();</span><br><span class="line">                Print.print(t.toString());</span><br><span class="line">                //insert into queue</span><br><span class="line">                butteredQueue.put(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            Print.print(&quot;butterer interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Print.print(&quot;butterer off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//step3:apply jam to buttered toast</span><br><span class="line">class Jammer implements Runnable&#123;</span><br><span class="line">    private ToastQueue butteredQueue,finishQueue;</span><br><span class="line">    public Jammer(ToastQueue butteredQueue,ToastQueue finishQueue)&#123;</span><br><span class="line">        this.finishQueue = finishQueue;</span><br><span class="line">        this.butteredQueue = butteredQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                //block until next piece of toast if available</span><br><span class="line">                Toast t = butteredQueue.take();</span><br><span class="line">                t.jam();</span><br><span class="line">                Print.print(t.toString());</span><br><span class="line">                //insert into queue</span><br><span class="line">                finishQueue.put(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            Print.print(&quot;jammer interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Print.print(&quot;jammer off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//consume the toast</span><br><span class="line">class Eater implements Runnable&#123;</span><br><span class="line">    private ToastQueue finishQueue;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    public Eater(ToastQueue finishQueue)&#123;</span><br><span class="line">        this.finishQueue = finishQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                //block until next piece of toast is available</span><br><span class="line">                Toast t = finishQueue.take();</span><br><span class="line">                //verify that toast is coming in order and all pieces are getting jammed</span><br><span class="line">                if(t.getId()!=count++||t.getStatus()!= Toast.Status.JAMMED)&#123;</span><br><span class="line">                    Print.print(&quot;error : &quot;+t);</span><br><span class="line">                    System.exit(1);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    Print.print(&quot;chomp : &quot;+t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            Print.print(&quot;eater interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Print.print(&quot;eater off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ToastOMatic &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ToastQueue dryQueue = new ToastQueue();</span><br><span class="line">        ToastQueue butterQueue = new ToastQueue();</span><br><span class="line">        ToastQueue finishQueue = new ToastQueue();</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(new Toaster(dryQueue));</span><br><span class="line">        exec.execute(new Butterer(dryQueue,butterQueue));</span><br><span class="line">        exec.execute(new Jammer(butterQueue,finishQueue));</span><br><span class="line">        exec.execute(new Eater(finishQueue));</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Toast是一个使用enum值的优秀示例。注意，<strong>这个示例中没有任何显式的同步</strong>（即使用Lock对象或者synchronized关键字的同步），因为同步由队列（其内部是同步的）和系统的设计隐式地管理了–每片Toast在任何时刻都只由一个任务在操作。<strong>因为队列的阻塞，使得处理过程将被自动地挂起和恢复</strong>。在使用显式的wait()和notifyAll()时存在的类和类之间的耦合被消除了，因为每个类都只和它的BlockingQueue通信。</p>
<h2 id="21-6死锁"><a href="#21-6死锁" class="headerlink" title="21.6死锁"></a>21.6死锁</h2><p><strong>哲学家就餐</strong>问题就是一个经典的死锁例证。问题描述：作为哲学家，他们很穷，只能买5根筷子（更一般的讲，筷子和哲学家的数量相同）。他们围坐在桌子周围，每人之间放一根筷子。当一个哲学家要就餐时，这个哲学家必须同时拿到左边和右边的筷子。如果筷子被占用，那么哲学家就必须等待，直至可得到必需的筷子。</p>
<p>当下列四个条件同时满足时，就会发生死锁：</p>
<p>1.<strong>互斥条件</strong>。任务使用的资源中至少有一个是不能共享的。一根筷子一次就只能被一个哲学家使用。<br>2.<strong>至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源</strong>。哲学家必须拿着一根筷子然后等待另一根筷子。<br>3.<strong>资源不能被任务抢占，任务必须把资源释放当做普通事件</strong>。哲学家很有礼貌，他们不会从其他哲学家手上抢筷子。<br>4.<strong>必须要有循环等待</strong>。A等待B，B等待C，C等待A，这样就循环等待了。<strong>所有哲学家都试图先得到左边的筷子，然后得到右边的筷子</strong>，所以发生了循环等待。</p>
<p>因为要发生死锁，所有这些条件都必须全部满足，所以要防止死锁的话，<strong>只需破坏其中一个即可</strong>。在程序中，<strong>防止死锁最容易的方法是破坏第4个条件</strong>。</p>
<p>具体到哲学家问题中，如果最后一个哲学家被初始化称先拿右边的，再拿左边的，那么永远不会有循环等待，所以不会形成死锁。</p>
<h2 id="21-7新类库中的构件"><a href="#21-7新类库中的构件" class="headerlink" title="21.7新类库中的构件"></a>21.7新类库中的构件</h2><p>新构件：</p>
<p>1.CountDownLatch<br>它被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。</p>
<p>2.CyclicBarrier<br>它适用于这样的情况：你希望创建一个任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成（<strong>这看起来有些像join()</strong>）。它使得所有的并行任务都将在栅栏处列队，因此可以一致地向前移动。这非常像CountDownLatch，只是CountDownLatch是只触发一次的事件，而CyclicBarrier可以多次重用。</p>
<p>3.DelayQueue<br>这时一个无界的BlockingQueue，<strong>用于放置实现了Delayed接口的对象</strong>，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素，并且poll()将返回null（正因为这样，你不能将null放置在这种队列中）。</p>
<p>4.PriorityBlockingQueue<br>这是一个很基础的优先级队列，它具有可阻塞的读取操作。</p>
<p>5.Semaphore<br>正常的锁（来自concurrent.locks或者synchronized锁）在任何时刻都只允许一个任务访问一项资源，<strong>而计数信号量允许n个任务同时访问这个资源</strong>。你可以将信号量看做是在向外分发使用资源的“许可证”，尽管实际上没有使用任何许可证对象。</p>
<p>6.Exchanger<br>Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。Exchanger的典型应用场景是：一个任务在创建对象，这些对象的生产代价很高，而另一个任务在消费这些对象。通过这种方式，可以有更多的对象在被创建的同时被消费。</p>
<h2 id="21-8仿真"><a href="#21-8仿真" class="headerlink" title="21.8仿真"></a>21.8仿真</h2><p><em>1.银行出纳员仿真</em></p>
<p>这个经典的仿真可以表示任何属于下面这种类型的情况：<strong>1.对象随机地出现</strong>，并且<strong>2.要求由数量有限的服务器提供随机数量的服务时间</strong>。通过构建仿真可以确定理想的服务器数量。</p>
<p>本例中，每个银行顾客要求一定数量的服务时间，这是出纳员必须花费在顾客身上，以服务顾客要求的时间单位的数量。服务时间的数量对每个顾客来说都是不同的，并且是随机确定的。另外，你不知道在每个时间间隔内有多少顾客会到达，因此这也是随机确定的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">//read-only objects dont require synchronization</span><br><span class="line">class Customer&#123;</span><br><span class="line">    private final int serviceTime;</span><br><span class="line">    public Customer(int serviceTime)&#123;</span><br><span class="line">        this.serviceTime = serviceTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getServiceTime() &#123;</span><br><span class="line">        return serviceTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;[ &quot;+serviceTime+&quot; ]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//teach the customer line to display itself</span><br><span class="line">class CustomerLine extends ArrayBlockingQueue&lt;Customer&gt;&#123;</span><br><span class="line">    public CustomerLine(int maxLineSize)&#123;</span><br><span class="line">        super(maxLineSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        if(this.size()==0)&#123;</span><br><span class="line">            return &quot;[empty]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder result = new StringBuilder();</span><br><span class="line">        for (Customer customer:this)&#123;</span><br><span class="line">            result.append(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//randomly add customers to a queue</span><br><span class="line">class CustomerGenerator implements Runnable&#123;</span><br><span class="line">    private CustomerLine customers;</span><br><span class="line">    private static Random rand = new Random(47);</span><br><span class="line">    public CustomerGenerator(CustomerLine customerLine)&#123;</span><br><span class="line">        customers = customerLine;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(rand.nextInt(300));</span><br><span class="line">                customers.put(new Customer(rand.nextInt(1000)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            Print.print(&quot;customer generator interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Print.print(&quot;customer generator end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teller implements Runnable,Comparable&lt;Teller&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private static int counter = 0;</span><br><span class="line">    private final int id = counter++;</span><br><span class="line">    //customers served during this shift</span><br><span class="line">    private int customersServed = 0;</span><br><span class="line">    private CustomerLine customers;</span><br><span class="line">    private boolean servingCustomerLine = true;</span><br><span class="line">    public Teller(CustomerLine cq)&#123;</span><br><span class="line">        customers = cq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //used by priority queue</span><br><span class="line">    //在priority queue中排序比较的值为customersServed</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized  int compareTo(Teller other) &#123;</span><br><span class="line">        return customersServed&lt;other.customersServed?-1:(customersServed==other.customersServed?0:1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                //serve customer from the line</span><br><span class="line">                Print.print(&quot;teller take a customer&quot;);</span><br><span class="line">                Customer customer = customers.take();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(customer.getServiceTime());</span><br><span class="line">                synchronized (this)&#123;</span><br><span class="line">                    customersServed++;</span><br><span class="line">                    while(!servingCustomerLine)&#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                Print.print(this+&quot; interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Print.print(this+&quot; end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doSthElse()&#123;</span><br><span class="line">        customersServed = 0;</span><br><span class="line">        servingCustomerLine = false;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void serveCustomerLine()&#123;</span><br><span class="line">        assert !servingCustomerLine:&quot;already serving &quot;+this;</span><br><span class="line">        servingCustomerLine = true;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;teller &quot;+id+&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String shortString() &#123;</span><br><span class="line">        return &quot;T &quot;+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TellerManager implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private ExecutorService exec;</span><br><span class="line">    private CustomerLine customers;</span><br><span class="line">    private PriorityBlockingQueue&lt;Teller&gt; workingTellers = new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">    private Queue&lt;Teller&gt; tellersDoingOtherThings = new LinkedList&lt;Teller&gt;();</span><br><span class="line">    private int adjustmentPeriod;</span><br><span class="line">    private static Random rand = new Random(47);</span><br><span class="line">    public TellerManager(ExecutorService e,CustomerLine customers,int adjustmentPeriod)&#123;</span><br><span class="line">        exec = e;</span><br><span class="line">        this.customers = customers;</span><br><span class="line">        this.adjustmentPeriod = adjustmentPeriod;</span><br><span class="line">        //start with a single teller</span><br><span class="line">        Teller teller = new Teller(customers);</span><br><span class="line">        Print.print(&quot;construct method&quot;);</span><br><span class="line">        exec.execute(teller);</span><br><span class="line">        workingTellers.add(teller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void adjustTellerNumber()&#123;</span><br><span class="line">        //this is actually a control system by adjusting</span><br><span class="line">        //the numbers. you can reveal stability issues in</span><br><span class="line">        //the conttol mechanism</span><br><span class="line">        //if line is too long. add another teller:</span><br><span class="line">        if(customers.size()/workingTellers.size()&gt;2)&#123;</span><br><span class="line">            //if tellers are on break or doing</span><br><span class="line">            //another job,bring one back</span><br><span class="line">            Print.print(&quot;size is too large&quot;+customers.size()+&quot; &quot;+workingTellers.size());</span><br><span class="line">            if(tellersDoingOtherThings.size()&gt;0)&#123;</span><br><span class="line">                Print.print(&quot;bring sthElse teller back&quot;);</span><br><span class="line">                Teller teller = tellersDoingOtherThings.remove();</span><br><span class="line">                teller.serveCustomerLine();</span><br><span class="line">                //Inserts the specified element into this priority queue.</span><br><span class="line">                workingTellers.offer(teller);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //else create(hire) a new teller</span><br><span class="line">            Print.print(&quot;hire a teller&quot;);</span><br><span class="line">            Teller teller = new Teller(customers);</span><br><span class="line">            exec.execute(teller);</span><br><span class="line">            workingTellers.add(teller);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //if line ts short enough,remove a teller</span><br><span class="line">        if(workingTellers.size()&gt;1&amp;&amp;customers.size()/workingTellers.size()&lt;2)&#123;</span><br><span class="line">            reassingOneTeller();</span><br><span class="line">        &#125;</span><br><span class="line">        //if there is no line, we only need one teller</span><br><span class="line">        if(customers.size()==0)&#123;</span><br><span class="line">            while(workingTellers.size()&gt;1)&#123;</span><br><span class="line">                reassingOneTeller();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //give a teller a different job or a break</span><br><span class="line">    private void reassingOneTeller() &#123;</span><br><span class="line">        Print.print(&quot;reassing one teller&quot;);</span><br><span class="line">        Teller teller = workingTellers.poll();</span><br><span class="line">        teller.doSthElse();</span><br><span class="line">        tellersDoingOtherThings.offer(teller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(!Thread.interrupted())&#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(adjustmentPeriod);</span><br><span class="line">                adjustTellerNumber();</span><br><span class="line">                System.out.println(&quot;\n&quot;);</span><br><span class="line">                System.out.print(&quot;customers: &quot;+customers +&quot;   ---   &quot; );</span><br><span class="line">                System.out.print(&quot;working tellers: &#123; &quot;);</span><br><span class="line">                for(Teller teller:workingTellers)&#123;</span><br><span class="line">                    System.out.print(teller.shortString()+&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(&quot; &#125;   ---   &quot;);</span><br><span class="line">                System.out.print(&quot;doSthElse tellers: &#123; &quot;);</span><br><span class="line">                for(Teller teller:tellersDoingOtherThings)&#123;</span><br><span class="line">                    System.out.print(teller.shortString()+&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(&quot; &#125;&quot;);</span><br><span class="line">                System.out.println(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            Print.print(this+ &quot;interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Print.print(this+&quot; end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;teller manager &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BankTellerSimulation&#123;</span><br><span class="line">    static final int MAX_LINE=50;</span><br><span class="line">    static final int ADJUSTMENT_PERIOD = 1000;</span><br><span class="line">    public static void main(String[] args)throws Exception&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        //if line is too long,customers will leave</span><br><span class="line">        CustomerLine customers = new CustomerLine(MAX_LINE);</span><br><span class="line">        exec.execute(new CustomerGenerator(customers));</span><br><span class="line">        //manager will add and remove tellers as necessary:</span><br><span class="line">        exec.execute(new TellerManager(exec,customers,ADJUSTMENT_PERIOD));</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">construct method</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">size is too large3 1</span><br><span class="line">hire a teller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">teller take a customer</span><br><span class="line">customers: [ 200 ][ 207 ]   ---   working tellers: &#123; T 1 T 0  &#125;   ---   doSthElse tellers: &#123;  &#125;</span><br><span class="line"></span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">customers: [ 861 ][ 258 ][ 140 ][ 322 ]   ---   working tellers: &#123; T 1 T 0  &#125;   ---   doSthElse tellers: &#123;  &#125;</span><br><span class="line"></span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">size is too large6 2</span><br><span class="line">hire a teller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">customers: [ 575 ][ 342 ][ 804 ][ 826 ][ 896 ][ 984 ]   ---   working tellers: &#123; teller take a customer</span><br><span class="line">T 2 T 0 T 1  &#125;   ---   doSthElse tellers: &#123;  &#125;</span><br><span class="line"></span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">size is too large10 3</span><br><span class="line">hire a teller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">customers: [ 984 ][ 810 ][ 141 ][ 12 ][ 689 ][ 992 ][ 976 ][ 368 ][ 395 ][ 354 ]   ---   working tellers: &#123; teller take a customer</span><br><span class="line">T 3 T 2 T 1 T 0  &#125;   ---   doSthElse tellers: &#123;  &#125;</span><br><span class="line"></span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller take a customer</span><br><span class="line">teller 1  interrupted</span><br><span class="line">customer generator interrupted</span><br><span class="line">customer generator end</span><br><span class="line">teller 3  interrupted</span><br><span class="line">teller 3  end</span><br><span class="line">teller 2  interrupted</span><br><span class="line">teller manager interrupted</span><br><span class="line">teller manager  end</span><br><span class="line">teller 0  interrupted</span><br><span class="line">teller 0  end</span><br><span class="line">teller 1  end</span><br><span class="line">teller 2  end</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>根据场景确定几个类：<br>1.客户类：Customer<br>2.客户队列：CustomerLine<br>3.向队列里面添加客户的Runnable：CustomerGenerator<br>4.收银服务员Runnable：Teller<br>5.管理调度服务员和客户队列的Runnable：TellerManager</p>
<p>主main方法中exec不直接调用Teller这个Runnable，而是通过TellerManager的构造方法将exec向下传递，在其他方法中调用Teller的run()方法。</p>
<p>为了选择下一个出纳员，让其回到服务顾客的业务上，compareTo()方法将查看出纳员服务过的顾客数量，使得PriorityQueue可以自动地将工作量最小的出纳员推向前台。</p>
<p><strong>TellerManager是各种活动的中心</strong>，它跟踪所有的出纳员以及等待服务的顾客。</p>
<h2 id="21-9性能调优"><a href="#21-9性能调优" class="headerlink" title="21.9性能调优"></a>21.9性能调优</h2><h3>21.9.1比较各类互斥技术</h3>

<p>既然Java包含老式的<strong>synchronized</strong>关键字和Java SE5中新的<strong>Lock</strong>和<strong>Atomic</strong>类，那么比较这些不同的方式，更多地了解它们各自的价值和使用范围，就会显得特别有意义。</p>
<p>比较天真的方式是针对每种方式都执行一个简单的测试。</p>
<p>但是，这容易出现<strong>“微基准测试”危险</strong>。这个术语通常指在隔离的，隔离上下文环境的情况下对某个特性进行性能测试。</p>
<p><strong>很明显</strong>，使用Lock通常会使用synchronized要高效很多，而且synchronized的开销看起来变化范围太大，而Lock相对比较一致。那是否意味着永远不应该使用synchronized关键字呢？错！主要有两个原因：</p>
<p>1.在测试环境中，互斥方法的方法体是非常小的，通常这是一个很好的习惯—只互斥那些你绝对必须互斥的部分。但是，在实际中，可能会有很大的互斥体。那么在这些方法体中花费的时间会明显大于进入和退出互斥的开销，这样也就淹没了提高互斥速度带来的所有好处。也就是说，<strong>synchronized进入和退出的开销比较大，而运行速度比较快</strong>。<br>2.synchronized产生的代码比Lock产生的代码比，可读性提高了很多。</p>
<p><strong>Atomic对象只有在非常简单的情况下才有用，这些情况通常包括你只有一个要被修改的Atomic对象，并且这个对象独立于其他所有的对象</strong>。</p>
<p>所以安全的推荐的方法是：以更加传统的方式（synchronized或Lock）入手，只有在性能方面的需求能够有明确指示时再替换为Atomic。</p>
<h3>21.9.2免锁容器</h3>

<p>容器是所有编程中的基础工具，这其中自然也包括了并发编程，但早期的容器类，内部使用了大量的synchronized方法，用于多线程时，开销很大。Java SE5添加了新的容器，通过使用更灵巧的技术来消除加锁，从而提高了线程安全的性能。<strong>从上面可以推断出简单地通过synchronized来进行同步并不怎么高效</strong>。</p>
<p>这些免锁容器背后的<strong>通用策略</strong>是：<strong>对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可</strong>。修改是在容器数据结构的某个部分的一个单独副本（有时是整个数据结构的副本）上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的数据结构才会主动地与主数据结构进行交换，之后读取者就可以看到这个修改了。这有点像数据库主从复制的策略，这种思想比较常见。</p>
<p>比如，<strong>CopyOnWriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException</strong>，因此你不必编写特殊的代码去防范这种异常，就像你以前必须做的那样。</p>
<p>此外，新增加的跟CopyOnWriteArrayList相似的还有，CopyOnWriteArraySet，ConcurrentHashMap和ConcurrentLinkedQueue也使用了类似的技术。</p>
<p><strong>乐观锁</strong>：</p>
<p><strong>只要你主要是从免锁容器中读取，那么它就会比其synchronized对应物快很多，因为获取和释放锁的开销被省掉了。如果需要先免锁容器中执行少量写入，情况仍旧如此</strong>，但是什么是“少量”呢？</p>
<h3>21.9.3乐观加锁</h3>

<p>尽管Atomic对象将执行像decrementAndGet()这样的原子操作，但是<strong>某些Atomic类还允许你执行所谓的“乐观加锁”</strong>。这意味着当你执行某项计算时，实际上没有使用互斥，但是<strong>1.在这项计算完成，并且2.你准备更新这个Atomic对象时，你需要使用一个称为compareAndSet()的方法</strong>。</p>
<p>你将旧值和新值一起提交给这个compareAndGet()方法，如果旧值与它在Atomic对象中发现的值不一致，那么这个操作就失败—这意味着某个其他的任务已经于此操作执行期间修改了这个对象。</p>
<p>记住，我们在正常情况下将使用互斥（synchronized或者Lock）来防止多个任务同时修改一个对象，但是这里我们是“乐观的”，因为我们保持树为未锁状态，并希望没有任何其他任务插入修改它。所有这些又都是以性能的名义执行的—通过使用Atomic来替代synchronized或Lock，可以获得性能上的好处。</p>
<p>这里补充下“乐观锁”的知识：</p>
<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<p>一个重要的问题是，<strong>如果compareAndSet()操作失败会发生什么</strong>？这正是棘手的地方，也是你在应用这项技术时的受限之处，即只能针对能够吻合这些需求的问题。</p>
<p>一个例子：</p>
<p>考虑一个假想的仿真，它由长度为30的10000个基因构成，这可能是某种遗传算法的起源。假设伴随着遗传算法的每次“进化”，都会发生某些代价高昂的计算，因此你决定使用一台多处理器机器来分布这些任务以提高性能。另外，你将使用Atomic对象而不是传统的互斥技术来实现（它们太慢了）。因为你的模型的特性，使得如果在计算过程中产生冲突，那么发现冲突的任务将直接忽略它，并不会更新它的值。下面是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class FastSimulation &#123;</span><br><span class="line">    static final int N_ELEMENTS = 10000;</span><br><span class="line">    static final int N_GENES = 30;</span><br><span class="line">    static final int N_EVOLVERS = 50;</span><br><span class="line">    static  final AtomicInteger[][] GRID = new AtomicInteger[N_ELEMENTS][N_GENES];</span><br><span class="line">    static Random rand = new Random(47);</span><br><span class="line">    static class Evolver implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (GRID)&#123;</span><br><span class="line">                while(!Thread.interrupted())&#123;</span><br><span class="line">                    //randomly select an element to work on</span><br><span class="line">                    int element = rand.nextInt(N_ELEMENTS);</span><br><span class="line">                    for (int i = 0; i &lt; N_GENES; i++) &#123;</span><br><span class="line">                        int previous = element-1;</span><br><span class="line">                        if (previous&lt;0)&#123;</span><br><span class="line">                            previous = N_ELEMENTS-1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        int next = element+1;</span><br><span class="line">                        if(next&gt;=N_ELEMENTS)&#123;</span><br><span class="line">                            next = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        int oldValue = GRID[element][i].get();</span><br><span class="line">                        //perform some kind of modeling calculation</span><br><span class="line">                        int newValue = oldValue+GRID[previous][i].get()+GRID[next][i].get();</span><br><span class="line">                        newValue /=3;//average the three values</span><br><span class="line">                        if (!GRID[element][i].compareAndSet(oldValue,newValue))&#123;</span><br><span class="line">                            //deal with failure</span><br><span class="line">                            Print.print(&quot;old value changed from &quot;+oldValue);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)throws InterruptedException&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        //init</span><br><span class="line">        for (int i = 0; i &lt; N_ELEMENTS; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; N_GENES; j++) &#123;</span><br><span class="line">                GRID[i][j] = new AtomicInteger(rand.nextInt(1000));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; N_EVOLVERS; i++) &#123;</span><br><span class="line">            exec.execute(new Evolver());</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(5000);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码如果不加synchronized语句块，就会产生值冲突。</p>
<h3>21.9.4ReadWriteLock</h3>

<p>ReadWriteLock对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读取者，只要它们不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</p>
<h2 id="21-10活动对象"><a href="#21-10活动对象" class="headerlink" title="21.10活动对象"></a>21.10活动对象</h2><p>读完本章，可能会发现，多线程非常复杂又难以正确使用。尽管多个任务可以并行工作，但是必须花大力气其防止这些任务之间彼此互相干涉的技术。</p>
<p>是多线程模型自身有问题吗？因为它来自于过程型编程世界，可能存在另一种不同的并发模型，更适合面向对象编程。<strong>有一种可替换的方式称为活动对象或行动者</strong>。之所以称这些对象是“活动的”，是因为每个对象都维护者他们自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中的一个。</p>
<h2 id="21-11总结"><a href="#21-11总结" class="headerlink" title="21.11总结"></a>21.11总结</h2><p>读完本章并发的基础知识，应该理解：</p>
<p>1.可以运行多个独立的任务<br>2.必须考虑当这些任务关闭时，可能出现的所有问题<br>3.任务可能会在共享资源上彼此干涉。互斥（锁）是用来防止这种冲突的基本工具<br>4.如果任务设计得不够仔细，就会发生死锁</p>
<p>线程的一个额外好处是他们提供了轻量级的执行上下文切换（大概100条指令），而是重量级的进程上下文切换（上千条指令）。<strong>因为一个给定的进程内的所有线程共享相同的内存空间，轻量级的上下文切换只是改变了程序的执行序列和局部变量</strong>。而进程切换必须改变所有的内存空间。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java编程思想读书笔记/">Java编程思想读书笔记</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/10/23/21-并发/" data-title="21.并发 | 曾先生&#39;s Blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/10/28/Spring in action--Part4-Integrating Spring/" title="Spring in action--Part4-Integrating Spring">
  <strong>上一篇：</strong><br/>
  <span>
  Spring in action--Part4-Integrating Spring</span>
</a>
</div>


<div class="next">
<a href="/2016/10/18/Spring in action--Part3-Spring in the back end/"  title="Spring in action--Part3-Spring in the back end">
 <strong>下一篇：</strong><br/> 
 <span>Spring in action--Part3-Spring in the back end
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/10/23/21-并发/" data-title="21.并发" data-url="http://yoursite.com/2016/10/23/21-并发/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-1并发的多面性"><span class="toc-number">1.</span> <span class="toc-text">21.1并发的多面性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.1.</span> <span class="toc-text">21.1.1更快的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.2.</span> <span class="toc-text">21.1.2改进代码设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-2基本的线程机制"><span class="toc-number">2.</span> <span class="toc-text">21.2基本的线程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.1.</span> <span class="toc-text">21.2.1定义任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.2.</span> <span class="toc-text">21.2.2Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.3.</span> <span class="toc-text">21.2.3使用Executor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.4.</span> <span class="toc-text">21.2.4从任务中产生返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.5.</span> <span class="toc-text">21.2.5休眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.6.</span> <span class="toc-text">21.2.6优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.7.</span> <span class="toc-text">21.2.7让步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.8.</span> <span class="toc-text">21.2.8后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.9.</span> <span class="toc-text">21.2.9编码的变体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.10.</span> <span class="toc-text">21.2.10术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.11.</span> <span class="toc-text">21.1.11加入一个线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.12.</span> <span class="toc-text">21.2.12创建有响应的用户界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.13.</span> <span class="toc-text">21.2.13线程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.14.</span> <span class="toc-text">21.2.14捕获异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-3共享受限资源"><span class="toc-number">3.</span> <span class="toc-text">21.3共享受限资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.1.</span> <span class="toc-text">21.3.1不正确地访问资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.2.</span> <span class="toc-text">21.3.2解决共享资源竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.3.</span> <span class="toc-text">21.3.3原子性与易变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.4.</span> <span class="toc-text">21.3.4原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.5.</span> <span class="toc-text">21.3.5临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.6.</span> <span class="toc-text">21.3.6在其他对象上同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.7.</span> <span class="toc-text">21.3.7线程本地存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-4终结任务"><span class="toc-number">4.</span> <span class="toc-text">21.4终结任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.</span> <span class="toc-text">21.4.2在阻塞时终结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.</span> <span class="toc-text">21.4.3中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.3.</span> <span class="toc-text">21.4.4检查中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-5线程之间的协作"><span class="toc-number">5.</span> <span class="toc-text">21.5线程之间的协作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.1.</span> <span class="toc-text">21.5.1notify()与notifyAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.2.</span> <span class="toc-text">21.5.2notify()与notifyAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.3.</span> <span class="toc-text">21.5.3生产者与消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.4.</span> <span class="toc-text">21.5.4生产者-消费者与队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-6死锁"><span class="toc-number">6.</span> <span class="toc-text">21.6死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-7新类库中的构件"><span class="toc-number">7.</span> <span class="toc-text">21.7新类库中的构件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-8仿真"><span class="toc-number">8.</span> <span class="toc-text">21.8仿真</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-9性能调优"><span class="toc-number">9.</span> <span class="toc-text">21.9性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">9.1.</span> <span class="toc-text">21.9.1比较各类互斥技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">9.2.</span> <span class="toc-text">21.9.2免锁容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">9.3.</span> <span class="toc-text">21.9.3乐观加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">9.4.</span> <span class="toc-text">21.9.4ReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-10活动对象"><span class="toc-number">10.</span> <span class="toc-text">21.10活动对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-11总结"><span class="toc-number">11.</span> <span class="toc-text">21.11总结</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/Java编程思想读书笔记/" style="font-size: 16.67px;">Java编程思想读书笔记</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/TECH/" style="font-size: 11.67px;">TECH</a> <a href="/tags/后端开发/" style="font-size: 18.33px;">后端开发</a> <a href="/tags/数据结构与算法分析/" style="font-size: 11.67px;">数据结构与算法分析</a> <a href="/tags/机器学习/" style="font-size: 13.33px;">机器学习</a> <a href="/tags/程序人生/" style="font-size: 10px;">程序人生</a> <a href="/tags/程序员修炼之道读书笔记/" style="font-size: 13.33px;">程序员修炼之道读书笔记</a> <a href="/tags/算法4读书笔记/" style="font-size: 15px;">算法4读书笔记</a>
    </div>
  </div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://lucida.me/" target="_blank" title="Lucida&#39;s Blog">Lucida&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://hukai.me/" target="_blank" title="Hukai&#39;s Blog">Hukai&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://gank.io/" target="_blank" title="GANK">GANK</a>
            
          </li>
        
          <li>
            
            	<a href="http://stormzhang.com/" target="_blank" title="StormZhang&#39;s Blog">StormZhang&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.trinea.cn/" target="_blank" title="Trinea&#39;s Blog">Trinea&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=2766fecb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello , I&#39;m Zeng Qi , a Android developer , love Java , ML and Big Data . <br/>
			This is my blog , hope you will enjoy it . Let&#39;s make this world a better place .</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/18600103348" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/zengqi-ustb" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/ceng-qi-29" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:zengqiustb@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		© 2016 
		
		<a href="/about" target="_blank" title="曾奇">曾奇</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"zengqi"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
